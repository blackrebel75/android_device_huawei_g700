From 1397d2b6705d32f20981d16a68514158f9ee0823 Mon Sep 17 00:00:00 2001
From: blackrebel <72fabio1@virgilio.it>
Date: Tue, 6 Mar 2018 17:33:25 +0100
Subject: [PATCH 05/18] [MTK]: Patch for camera recording and hw video enc/dec

Issue: Video playback with mtk hw decoder show black screen

Change-Id: I61b5748371786564327f6079eb1aa98b5d7c00c6

# Conflicts:
#	include/media/stagefright/CameraSource.h
#	include/media/stagefright/ColorConverter.h
#	include/media/stagefright/OMXCodec.h
#	media/libmediaplayerservice/Android.mk
#	media/libmediaplayerservice/StagefrightRecorder.cpp
#	media/libmediaplayerservice/StagefrightRecorder.h
#	media/libstagefright/Android.mk
#	media/libstagefright/CameraSource.cpp
#	media/libstagefright/OMXCodec.cpp
#	media/libstagefright/SurfaceMediaSource.cpp
#	media/libstagefright/colorconversion/Android.mk
#	media/libstagefright/colorconversion/ColorConverter.cpp
#	media/libstagefright/include/OMXNodeInstance.h
#	media/libstagefright/omx/Android.mk
#	media/libstagefright/omx/OMXNodeInstance.cpp
---
 include/media/IOMX.h                               |   22 +
 include/media/stagefright/ACodec.h                 |   49 +
 include/media/stagefright/CameraSource.h           |   32 +-
 include/media/stagefright/ColorConverter.h         |   10 +
 include/media/stagefright/MediaBuffer.h            |    9 +
 include/media/stagefright/MediaDefs.h              |    3 +
 include/media/stagefright/MediaErrors.h            |   10 +
 include/media/stagefright/MetaData.h               |   79 +-
 include/media/stagefright/OMXCodec.h               |  113 +-
 include/media/stagefright/SurfaceMediaSource.h     |   23 +
 media/libmedia/Android.mk                          |   13 +
 media/libmedia/IOMX.cpp                            |  196 +++
 media/libmediaplayerservice/Android.mk             |   11 +-
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  168 +-
 media/libmediaplayerservice/StagefrightRecorder.h  |   20 +
 media/libstagefright/ACodec.cpp                    |  845 ++++++++-
 media/libstagefright/Android.mk                    |   33 +
 media/libstagefright/CameraSource.cpp              |  175 +-
 media/libstagefright/MediaBuffer.cpp               |   22 +
 media/libstagefright/MediaCodec.cpp                |    6 +
 media/libstagefright/MediaDefs.cpp                 |    3 +
 media/libstagefright/OMXClient.cpp                 |   47 +
 media/libstagefright/OMXCodec.cpp                  | 1790 +++++++++++++++++++-
 media/libstagefright/SurfaceMediaSource.cpp        |  422 +++++
 media/libstagefright/codecs/aacenc/Android.mk      |    2 +-
 media/libstagefright/colorconversion/Android.mk    |    6 +
 .../colorconversion/ColorConverter.cpp             |  261 ++-
 media/libstagefright/include/OMX.h                 |   19 +
 media/libstagefright/include/OMXNodeInstance.h     |   22 +
 media/libstagefright/omx/Android.mk                |   11 +
 media/libstagefright/omx/OMX.cpp                   |   38 +
 media/libstagefright/omx/OMXNodeInstance.cpp       |  245 ++-
 32 files changed, 4578 insertions(+), 127 deletions(-)

diff --git a/include/media/IOMX.h b/include/media/IOMX.h
index 6e4a4acf5..4653f33c9 100644
--- a/include/media/IOMX.h
+++ b/include/media/IOMX.h
@@ -27,6 +27,9 @@
 #include <OMX_Core.h>
 #include <OMX_Video.h>
 
+#ifdef MTK_HARDWARE
+#include <binder/IMemory.h>
+#endif
 namespace android {
 
 class IMemory;
@@ -156,6 +159,25 @@ public:
             InternalOptionType type,
             const void *data,
             size_t size) = 0;
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer) = 0;
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer) = 0;
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) = 0;
+
+    virtual status_t registerBuffer2(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &HeapBase) = 0;
+
+    virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) = 0;
+#endif
 };
 
 struct omx_message {
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 3ffac34a5..106d4682c 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -31,6 +31,10 @@
 
 #define TRACK_BUFFER_TIMING     0
 
+#ifdef MTK_HARDWARE
+#define VIDEO_M4U_MAX_BUFFER 100
+#endif
+
 #define CODEC_PLAYER_STATS(func, ...) \
     do { \
         if(mCodec != NULL && mCodec->mMediaExtendedStats != NULL) { \
@@ -64,6 +68,15 @@ struct ACodec : public AHierarchicalStateMachine, public CodecBase {
     virtual void signalEndOfInputStream();
     virtual void signalRequestIDRFrame();
 
+#ifdef MTK_HARDWARE
+    void signalVEncIInterval(int seconds);
+    status_t setVEncIInterval(int seconds);     //should be private
+    void signalVEncBitRate(int bitrate);
+    status_t setVEncBitRate(int bitrate);       //should be private
+    void signalVEncFrameRate(int framerate);
+    status_t setVEncFrameRate(int framerate);   //should be private
+#endif
+
     // AHierarchicalStateMachine implements the message handling
     virtual void onMessageReceived(const sp<AMessage> &msg) {
         handleMessage(msg);
@@ -129,6 +142,11 @@ private:
         kWhatRequestIDRFrame         = 'ridr',
         kWhatSetParameters           = 'setP',
         kWhatSubmitOutputMetaDataBufferIfEOS = 'subm',
+#ifdef MTK_HARDWARE
+        kWhatMtkVEncIFrameInterval   = 'MVeI',
+        kWhatMtkVEncBitRate          = 'MVeB',
+        kWhatMtkVEncFrameRate        = 'MVeF',
+#endif
         kWhatOMXDied                 = 'OMXd',
         kWhatReleaseCodecInstance    = 'relC',
     };
@@ -151,6 +169,9 @@ private:
             OWNED_BY_UPSTREAM,
             OWNED_BY_DOWNSTREAM,
             OWNED_BY_NATIVE_WINDOW,
+#ifdef MTK_HARDWARE
+            OWNED_BY_UNEXPECTED
+#endif
         };
 
         IOMX::buffer_id mBufferID;
@@ -203,6 +224,26 @@ private:
     List<sp<AMessage> > mDeferredQueue;
 
     bool mSentFormat;
+#ifdef MTK_HARDWARE
+    bool mSupportsPartialFrames;
+    bool mIsVideoDecoder;
+    bool mIsVideoEncoder;
+    sp<ABuffer> mLeftOverBuffer;
+    int32_t mMaxQueueBufferNum;
+    FILE* mDumpFile;
+    bool mIsDumpFile;
+    int32_t mVideoAspectRatioWidth;
+    int32_t mVideoAspectRatioHeight;
+    bool mIsDemandNormalYUV;
+    size_t mAlignedSize;
+    void*  mM4UBufferHandle;
+    bool mIsDumpProflingFile;
+    unsigned long mM4UBufferCount;
+    unsigned long mM4UBufferSize[VIDEO_M4U_MAX_BUFFER];
+    unsigned long mM4UBufferVa[VIDEO_M4U_MAX_BUFFER]; 
+    unsigned long mM4UBufferPa[VIDEO_M4U_MAX_BUFFER];
+    unsigned long mM4UBufferHdr[VIDEO_M4U_MAX_BUFFER];
+#endif
     bool mIsEncoder;
     bool mUseMetadataOnEncoderOutput;
     bool mFatalError;
@@ -229,6 +270,14 @@ private:
     int64_t mRepeatFrameDelayUs;
     int64_t mMaxPtsGapUs;
 
+#ifdef MTK_HARDWARE
+    int32_t mIsVideoEncoderInputSurface;
+#if APPLY_CHECKING_FLUSH_COMPLETED
+    uint32_t mTotalTimeDuringCheckFlush;
+    int32_t mPortsFlushComplete;
+#endif //APPLY_CHECKING_FLUSH_COMPLETED
+#endif
+
     int64_t mTimePerFrameUs;
     int64_t mTimePerCaptureUs;
 
diff --git a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
index 85b841a3e..0f7fd64b9 100644
--- a/include/media/stagefright/CameraSource.h
+++ b/include/media/stagefright/CameraSource.h
@@ -91,7 +91,11 @@ public:
                                           Size videoSize,
                                           int32_t frameRate,
                                           const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+										 bool storeMetaDataInVideoBuffers = false, bool supportMCIbuffer = false);
+#else
                                           bool storeMetaDataInVideoBuffers = false);
+#endif
 
     virtual ~CameraSource();
 
@@ -130,6 +134,11 @@ public:
 
     virtual void signalBufferReturned(MediaBuffer* buffer);
 
+#ifdef MTK_HARDWARE
+	status_t setFrameRate(int32_t fps);
+//	status_t pause();
+	status_t resume();
+#endif
 protected:
     class ProxyListener: public BnCameraRecordingProxyListener {
     public:
@@ -184,8 +193,11 @@ protected:
                  int32_t cameraId, const String16& clientName, uid_t clientUid,
                  Size videoSize, int32_t frameRate,
                  const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+				bool storeMetaDataInVideoBuffers,bool supportMCIbuffer = false);	
+#else
                  bool storeMetaDataInVideoBuffers);
-
+#endif
     virtual status_t startCameraRecording();
     virtual void releaseRecordingFrame(const sp<IMemory>& frame);
 
@@ -255,6 +267,24 @@ private:
     void stopCameraRecording();
     status_t reset();
 
+#ifdef MTK_HARDWARE
+	void releaseCamera_l(bool locked = false);
+    float mDropRate;
+	int32_t mNumRemainFrameReceived;
+	int32_t mLastNumFramesReceived;
+	int32_t mCamVideoBufferMode;
+	//void* mVecCamBufInfo;
+	uint32_t* mCamMemVaArray;
+	int32_t* mCamMemIonFdArray;
+
+	//for MCI buffer to save bandwith during recording
+	bool mSupportMCIbuffer;
+	void* mCamRecSetting;
+	//CameraRecSetting mCamRecSetting;
+	bool volatile mPaused;
+	bool volatile mResumed;
+#endif
+
     CameraSource(const CameraSource &);
     CameraSource &operator=(const CameraSource &);
 };
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba92068..5ce0dd718 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -24,6 +24,9 @@
 #include <utils/Errors.h>
 
 #include <OMX_Video.h>
+#ifdef MTK_HARDWARE
+#include <ui/PixelFormat.h>
+#endif
 
 namespace android {
 
@@ -62,6 +65,13 @@ private:
     OMX_COLOR_FORMATTYPE mSrcFormat, mDstFormat;
     uint8_t *mClip;
 
+#ifdef MTK_HARDWARE
+    status_t convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst);
+    status_t convertYUV420PlanarToABGR8888(const BitmapParams &src, const BitmapParams &dst);
+    void dumpColorConverterData(const char * filepath, const void * buffer, size_t size,const char * propty);
+    bool SWYUVToRGBConversion(const BitmapParams &src, const BitmapParams &dst);
+    PixelFormat mPixelFormat;
+#endif
     uint8_t *initClip();
 
     status_t convertCbYCrY(
diff --git a/include/media/stagefright/MediaBuffer.h b/include/media/stagefright/MediaBuffer.h
index 5ab266f4c..b66dfe153 100644
--- a/include/media/stagefright/MediaBuffer.h
+++ b/include/media/stagefright/MediaBuffer.h
@@ -56,6 +56,9 @@ public:
 
     MediaBuffer(const sp<ABuffer> &buffer);
 
+#ifdef MTK_HARDWARE
+    MediaBuffer(size_t size, sp<MetaData> metaData);
+#endif
     // Decrements the reference count and returns the buffer to its
     // associated MediaBufferGroup if the reference count drops to 0.
     virtual void release();
@@ -120,6 +123,12 @@ private:
     MediaBuffer(const MediaBuffer &);
     MediaBuffer &operator=(const MediaBuffer &);
 };
+#ifdef MTK_HARDWARE
+class MediaBufferSimpleObserver: public MediaBufferObserver {
+public:
+    virtual void signalBufferReturned(MediaBuffer *buffer);
+};
+#endif
 
 }  // namespace android
 
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index bab6432ce..bb4ddb0a5 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -41,6 +41,9 @@ namespace android {
 
 extern const char *MEDIA_MIMETYPE_IMAGE_JPEG;
 
+#ifdef MTK_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
+#endif
 extern const char *MEDIA_MIMETYPE_VIDEO_VP8;
 extern const char *MEDIA_MIMETYPE_VIDEO_VP9;
 extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
diff --git a/include/media/stagefright/MediaErrors.h b/include/media/stagefright/MediaErrors.h
index f7e013df6..b24fe0e0e 100644
--- a/include/media/stagefright/MediaErrors.h
+++ b/include/media/stagefright/MediaErrors.h
@@ -76,6 +76,16 @@ enum {
     INFO_DOLBY_PROCESSED_AUDIO_START = MEDIA_ERROR_BASE - 15,
     INFO_DOLBY_PROCESSED_AUDIO_STOP = MEDIA_ERROR_BASE - 16,
 #endif // DOLBY_END
+#ifdef MTK_HARDWARE
+    FAKE_INFO_DISCONTINUITY     = MEDIA_ERROR_BASE - 20,
+    ERROR_FORBIDDEN        = MEDIA_ERROR_BASE - 100 - 0,
+    ERROR_POOR_INTERLACE   = MEDIA_ERROR_BASE - 100 - 1,
+    INFO_TRY_READ_FAIL	   = MEDIA_ERROR_BASE - 100 - 2,
+    ERROR_UNSUPPORTED_VIDEO= MEDIA_ERROR_BASE - 100 - 3,
+    ERROR_UNSUPPORTED_AUDIO= MEDIA_ERROR_BASE - 100 - 4,
+    ERROR_EOS_QUITNOW       = MEDIA_ERROR_BASE - 100 - 5,
+    ERROR_BUFFER_DEQUEUE_FAIL = MEDIA_ERROR_BASE - 100 - 6,
+#endif
 
     // The following constant values should be in sync with
     // drm/drm_framework_common.h
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index 3ac567aca..e1b641263 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -149,6 +149,60 @@ enum {
     kKeyWMVVersion        = 'wmvv',  // int32_t
     kKeyRVVersion         = '#rvv',  // int32_t
     kKeyBlockAlign        = 'blk',   // int32_t , should be different from kKeyWMABlockAlign
+#ifdef MTK_HARDWARE
+	kKeyIsLivePhoto 	  = 'islp',  //int32_t
+    kKeyVideoPreCheck	  = 'vpck',	 //int32_t(bool)
+    kKeyAudioPadEnable	  = 'apEn',	 //int32_t(bool),hai.li
+    kKeyMaxQueueBuffer    = 'mque',  //int32_t, Demon Deng for OMXCodec
+    kKeyAacObjType         = 'aaco',    // Morris Yang for MPEG4 audio object type
+    kKeySDP               = 'ksdp',  //int32_t, Demon Deng for SDP
+    kKeyUri					='kuri',//int32_t,haizhen for sdp
+    kKeyRvActualWidth     =  'rvaw', // int32_t, Morris Yang for RV
+    kKeyRvActualHeight    =  'rvah', // int32_t, Morris Yang for RV
+    kKeyServerTimeout     = 'srvt',  //int32_t, Demon Deng for RTSP Server timeout
+    kKeyIs3gpBrand		  = '3gpB',  //int32_t(bool), hai.li
+    kKeyIsQTBrand		  = 'qtBd',  //int32_t(bool), hai.li
+    kKeyFirstSampleOffset = 'FSOf',  //int64_t, hai.li
+    kKeyLastSampleOffset  = 'FSOl',  //int64_t, hai.li
+    kKeyMPEG4VOS			  = 'MP4C',  //raw data, hai.li for other container support mpeg4 codec
+    kKeyRTSPSeekMode      = 'rskm',  //int32_t, Demon Deng for RTSP Seek Mode
+    kKeyInputBufferNum    = 'inbf',  //int32_t, Demon Deng for OMXCodec
+    kKeyOutputBufferNum   = 'onbf',  //int32_t,for VE
+    kKeyHasUnsupportVideo = 'UnSV',  //int32_t(bool), hai.li, file has unsupport video track.
+    kKeyRTPTarget         = 'rtpt',  //int32_t, Demon Deng for ARTPWriter
+    kKeyCodecInfoIsInFirstFrame = 'CIFF', //int32(bool), hai.li,codec info is in the first frame 
+    kKeyCamMemInfo        = 'CMIf',  // int32_t, Morris Yang for OMXVEnc With Camera 
+    kKeyCamMCIMemInfo = 'CMCI', // pointer,, Morris Yang for Camera MCI mem info 
+    kKeyCamMCIMemSecurity ='CMSE',// int32_t, haizhen, for Camera MCI mem security info
+    kKeyCamMCIMemCoherent = 'CMCH', //int32_t,haizhen,for Camera MCI mem coherent info
+    //kKeyVecCamBufInfo	  = 'CMBI',  //pointer,haizhen for 89 cam buffer vector
+	kKeyCamMemMode        = 'CMMd', //add by haizhen for 89 cam Buffer mode
+	kKeyCamMemVaArray	  = 'CMAr',// add by haizhen for 89 cam buffer
+	kKeyCamMemIonFdArray  = 'CMIa', //add by haizhen for 89 ion cam buffer
+    kKeyCamWhiteboardEffect = 'CWEf',  // int32_t, Morris Yang for camera whiteboard effect (need to modify QP value for bitstream size)
+    kKeyCamMemVa		  = 'CMVa',	 //int32_t, camera yuv buffer virtual address
+    kKeyCamMemSize		  = 'CMSz',  //int32_t, camera yuv buffer size
+    kKeyCamMemCount		  = 'CMCt',  //int32_t, camera yuv buffer count
+    kKeyColorEffect		= 'CoEf',//cstring, camera color effect mode
+    kKeyAspectRatioWidth          =  'aspw',
+    kKeyAspectRatioHeight         =  'asph',
+    kKeyHLSVideoFirestRender   = 'v1Rn', //int64, timestamp, http live
+//    kKeyOutBufSize        = 'inbuf',//int32_t,for OMX Output Buffer Size
+    kKeyFrameNum          = 'frnu',//int32_t,for mp3 output buffer frame limit.
+    kKeySamplesperframe      = 'sapf', // int32_t samples per frame
+    kKeyRTSPOutputTimeoutUS = 'rsto',	// int64_t, omx output buf timeout for rtsp in US
+    kKeyHTTPOutputTimeoutUS = 'htpo',	// int64_t, omx output buf timeout for http in US
+    kKeyIsHTTPStreaming = 'htst',	// for omxcodec use
+//    kKeyWFDUseBufferPointer = 'usebufferpointer',
+//    kKeyWFDUseExternalDisplay = 'useexternaldisplay',
+    KKeyMultiSliceBS      = 'NalM',  //int32_t (bool), to indicate multi-slice Stream
+//	kKeyIsFromMP3Extractor = 'isFromMP3Extractor',
+//    kKeyTimeToSampleNumberEntry  = 'ttsne',  // int32_t
+//    kKeyTimeScaleOptional     = 'timesclop',  // int32_t
+//    kKeyTimeToSampleTable  = 'ttst',  // int32_t
+//    kKeySampleCount     = 'samplecnt',  // int32_t
+    kKeyRequiresMaxFBuffers = 'maxfb',  // bool (int32_t)
+#endif
 
     // An indication that a video buffer has been rendered.
     kKeyRendered          = 'rend',  // bool (int32_t)
@@ -163,7 +217,23 @@ enum {
 
     kKeyIsADTS            = 'adts',  // bool (int32_t)
     kKeyAACAOT            = 'aaot',  // int32_t
-
+#ifdef MTK_HARDWARE
+	kKeyCodecConfigInfo    = 'cinf',  // raw data
+	kkeyOmxTimeSource      = 'omts', 
+    kKeySupportTryRead     = 'tryR', //in32_t try read is supported
+	kKeyIsAACADIF		   = 'adif',  // int32_t (bool)
+	kKeyDataSourceObserver = 'dsob',	  //pointer, pointer of awesomeplayer weiguo
+	kKeyHasSEIBuffer	  = 'SEIB', //bool (int32_t)
+	kKeyVideoBitRate      = 'vbrt',// int32_t VR video Bitrate
+	kKeyVideoEncoder	  = 'venc', //int32_t VR encoder type refer MediaProfie.h
+	kKeyVQForMem 			= 'vqfm',  		// bool (int32_t)
+	kKeyVQForTemp 			= 'vqft',  		// bool (int32_t)
+//	kKeyHVCC				= 'hvcc',
+    kInvalidKeyTime         = 'invt',
+
+    kKeyVideoEditorVa   = 'VEVA',  // pointer
+    kKeyVideoEditorPa   = 'VEPA',  // pointer
+#endif
     // If a MediaBuffer's data represents (at least partially) encrypted
     // data, the following fields aid in decryption.
     // The data can be thought of as pairs of plain and encrypted data
@@ -210,6 +280,13 @@ enum {
     kTypeHVCC        = 'hvcc',
     kTypeD263        = 'd263',
 };
+#ifdef MTK_HARDWARE
+enum camera_mem_mode{
+	CAMERA_CONTINUOUS_MEM_MODE = 0, //camera mem is continus for 77
+	CAMERA_DISCONTINUOUS_MEM_VA_MODE = 1, //camera mem is discontinus for 89
+	CAMERA_DISCONTINUOUS_MEM_ION_MODE = 2,//camera mem is discontinus for 89--ion mem
+};
+#endif
 
 enum {
     kTypeDivXVer_3_11,
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index b57b49131..9e4077231 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -45,6 +45,13 @@
 
 #include <OMX_Audio.h>
 
+#ifdef MTK_HARDWARE
+#include <binder/MemoryHeapBase.h>
+// adb shell property flags
+#define OMXCODEC_ENABLE_VIDEO_INPUT_ERROR_PATTERNS  (1 << 0)
+#define OMXCODEC_THUMBNAIL_MODE                     (1 << 1)
+#endif
+
 #include <media/stagefright/ExtendedStats.h>
 
 #define PLAYER_STATS(func, ...) \
@@ -88,6 +95,11 @@ struct OMXCodec : public MediaSource,
 
         // Secure decoding mode
         kUseSecureInputBuffers = 256,
+#ifdef MTK_HARDWARE
+        kUseMaxOutputBuffers = 2048,
+        kUseClearMotion = 4096,
+        kUsePostProcessingFw = 16384,
+#endif
     };
     static sp<MediaSource> Create(
             const sp<IOMX> &omx,
@@ -106,6 +118,22 @@ struct OMXCodec : public MediaSource,
 
     virtual sp<MetaData> getFormat();
 
+#ifdef MTK_HARDWARE
+    virtual sp<MetaData> getCameraMeta();
+    status_t vEncSetForceIframe(bool enable);
+    status_t vDecSwitchBwTVout(bool enable);
+
+    status_t vEncSetFrameRate(unsigned int u4FrameRate);
+    status_t vEncSetBitRate(unsigned int u4BitRate);
+    sp<MediaSource> getSource() { return mSource; }
+
+    enum MtkEncScenario {
+        kCameraRecord = 1,
+        kLivePhotoCapture = 2,
+        kLivePhotoEffect = 4,
+    };
+    status_t vEncSetSenario(MtkEncScenario eScenario);
+#endif
     virtual status_t read(
             MediaBuffer **buffer, const ReadOptions *options = NULL);
 
@@ -128,6 +156,10 @@ struct OMXCodec : public MediaSource,
         kSupportsMultipleFramesPerInputBuffer = 1024,
         kRequiresLargerEncoderOutputBuffer    = 2048,
         kOutputBuffersAreUnreadable           = 4096,
+#ifdef MTK_HARDWARE
+        kAvoidMemcopyInputRecordingFrames     = 8192,
+        kDecoderNeedPrebuffer                 = 16384,        
+#endif
         kRequiresGlobalFlush                  = 0x20000000, // 2^29
         kRequiresWMAProComponent              = 0x40000000, //2^30
     };
@@ -155,6 +187,17 @@ struct OMXCodec : public MediaSource,
             const CodecProfileLevel& defaultProfileLevel,
             CodecProfileLevel& profileLevel);
 
+#ifdef MTK_HARDWARE
+    	size_t buffersOwn();
+	void resume();
+
+    //for videoeditor MVA mode
+    void *findInputBufferByDataNumber(OMX_U32 portIndex, uint32_t number);
+
+    // Added for video editor to query the number of empty input buffers.
+    uint32_t getEmptyInputBufferCount();
+#endif
+
 protected:
     virtual ~OMXCodec();
 
@@ -232,6 +275,10 @@ private:
     char *mMIME;
     char *mComponentName;
     sp<MetaData> mOutputFormat;
+#ifdef MTK_HARDWARE
+    sp<MetaData> mCameraMeta;
+    bool mIsHttpStreaming;
+#endif
     sp<MediaSource> mSource;
     Vector<CodecSpecificData *> mCodecSpecificData;
     size_t mCodecSpecificDataIndex;
@@ -263,7 +310,26 @@ private:
     bool mDolbyProcessedAudio;
     bool mDolbyProcessedAudioStateChanged;
 #endif // DOLBY_END
-
+#ifdef MTK_HARDWARE
+    bool mIsVideoDecoder;
+    bool mIsVideoEncoder;
+    unsigned char* mInputBufferPoolMemBase;
+    unsigned char* mOutputBufferPoolMemBase;
+    sp<MemoryHeapBase> mMemHeapBase;
+    uint32_t mPropFlags;
+    float mVideoInputErrorRate;
+    Condition mBufferSent;
+    // set this by calling start with kKeyMaxQueueBuffer in meta
+    size_t mMaxQueueBufferNum;
+    bool mQueueWaiting;
+    bool mSupportsPartialFrames;
+    MediaBufferSimpleObserver mOMXPartialBufferOwner;
+    int32_t mVideoAspectRatioWidth;
+    int32_t mVideoAspectRatioHeight;
+    bool mIsVENCTimelapseMode;
+    int64_t mRTSPOutputTimeoutUS;
+    int64_t mHTTPOutputTimeoutUS;
+#endif
     sp<ANativeWindow> mNativeWindow;
 
     // The index in each of the mPortBuffers arrays of the buffer that will be
@@ -353,6 +419,10 @@ private:
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
 #ifdef USE_SAMSUNG_COLORFORMAT
     void setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat);
+#endif
+#ifdef MTK_HARDWARE
+    status_t allocateBuffersOnInputPort();
+    status_t allocateBuffersOnOutputPort();
 #endif
     status_t allocateOutputBuffersFromNativeWindow();
 
@@ -366,15 +436,26 @@ private:
 
     status_t freeBuffer(OMX_U32 portIndex, size_t bufIndex);
 
+#ifdef MTK_HARDWARE
+    void PutErrorPatterns(uint8_t *pBuffer, uint32_t length);
+#endif
     bool drainInputBuffer(IOMX::buffer_id buffer);
     void fillOutputBuffer(IOMX::buffer_id buffer);
+#ifdef MTK_HARDWARE
+    bool drainInputBuffer(BufferInfo *info, bool init = false);
+#else
     bool drainInputBuffer(BufferInfo *info);
+#endif
     void fillOutputBuffer(BufferInfo *info);
 
     void drainInputBuffers();
     void fillOutputBuffers();
 
+#ifdef MTK_HARDWARE
+    bool drainAnyInputBuffer(bool init = false);
+#else
     bool drainAnyInputBuffer();
+#endif
     BufferInfo *findInputBufferByDataPointer(void *ptr);
     BufferInfo *findEmptyInputBuffer();
 
@@ -407,6 +488,9 @@ private:
     void dumpPortStatus(OMX_U32 portIndex);
 
     status_t configureCodec(const sp<MetaData> &meta);
+#ifdef MTK_HARDWARE
+    void restorePatchedDataPointer(BufferInfo *info);
+#endif
 
     status_t applyRotation();
     status_t waitForBufferFilled_l();
@@ -429,6 +513,10 @@ private:
     int32_t mNumBFrames;
     bool mInSmoothStreamingMode;
     bool mOutputCropChanged;
+#ifdef MTK_HARDWARE
+private:
+	int64_t mPreRollStartTime;
+#endif
 };
 
 struct CodecCapabilities {
@@ -472,7 +560,30 @@ status_t QueryCodec(
         CodecCapabilities *caps);
 
 status_t getOMXChannelMapping(size_t numChannels, OMX_AUDIO_CHANNELTYPE map[]);
+#ifdef MTK_HARDWARE
+#define VDOBUFCOUNT_MAX 16
+typedef struct
+{
+    uint32_t u4VdoBufCount;
+    uint32_t u4VdoBufSize;
+    uint32_t u4VdoBufVA[VDOBUFCOUNT_MAX];
+} CamMemInfo_t;
+
+typedef struct
+{
+    uint32_t u4VdoBufCount;
+    uint32_t u4VdoBufSize;
+    int          IonFd[VDOBUFCOUNT_MAX];
+    uint32_t u4VdoBufVA[VDOBUFCOUNT_MAX];
+} CamMemIonInfo_t;
+
+typedef struct
+{
+    uint32_t u4Security;
+    uint32_t u4Coherent;
+} CamMCIMemInfo_t;
 
+#endif
 }  // namespace android
 
 #endif  // OMX_CODEC_H_
diff --git a/include/media/stagefright/SurfaceMediaSource.h b/include/media/stagefright/SurfaceMediaSource.h
index d15a22672..223ec6b9a 100644
--- a/include/media/stagefright/SurfaceMediaSource.h
+++ b/include/media/stagefright/SurfaceMediaSource.h
@@ -234,6 +234,29 @@ private:
 
     // Avoid copying and equating and default constructor
     DISALLOW_IMPLICIT_CONSTRUCTORS(SurfaceMediaSource);
+#ifdef MTK_HARDWARE
+    void drainBufferQueue();
+    void dumpBuffer();
+
+    // for continuous buffers dump
+    int mContBufsDumpById;
+    uint32_t mBackupBufsIndex;
+    uint32_t mBackupBufsMax; 
+    Vector< sp<GraphicBuffer> > mBackBufs;
+
+    void dumpSingleBuffer();
+    void dumpGraphicBuffer(sp<GraphicBuffer> buf, int index);
+    void backupProcess(void* dst, void* src, size_t size);
+
+    bool mIsBinderDied;
+
+public:
+    status_t binderDied();
+
+    // for continuous buffers dump
+    void dumpContinuousBuffer();
+    virtual void activeBufferBackup();
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index 3a069b85d..6a53cb16a 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -22,6 +22,9 @@ endif
 
 include $(CLEAR_VARS)
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_CFLAGS += -DMTK_MT6589
+endif
 LOCAL_SRC_FILES:= \
     AudioTrack.cpp \
     AudioTrackShared.cpp \
@@ -114,6 +117,16 @@ LOCAL_STATIC_LIBRARIES += libinstantssq
 
 LOCAL_WHOLE_STATIC_LIBRARIES := libmedia_helper
 
+ifeq ($(TARGET_BOARD_PLATFORM),mt6589)
+LOCAL_STATIC_LIBRARIES += \
+        libmedia_helper
+LOCAL_SHARED_LIBRARIES += \
+        libvcodecdrv
+
+LOCAL_C_INCLUDES += \
+    $(TOP)/mediatek/platform/mt6589/hardware/vcodec/inc
+endif
+
 LOCAL_MODULE:= libmedia
 
 LOCAL_C_INCLUDES := \
diff --git a/media/libmedia/IOMX.cpp b/media/libmedia/IOMX.cpp
index 99c0d932e..ea16f0b06 100644
--- a/media/libmedia/IOMX.cpp
+++ b/media/libmedia/IOMX.cpp
@@ -57,6 +57,13 @@ enum {
     SET_INTERNAL_OPTION,
     UPDATE_GRAPHIC_BUFFER_IN_META,
     CONFIGURE_VIDEO_TUNNEL_MODE,
+#ifdef MTK_HARDWARE
+    USE_BUFFER2,
+    USE_BUFFER3,
+    REGISTER_BUFFER,
+    REGISTER_BUFFER2,
+    USE_ION_BUFFER,
+#endif
 };
 
 class BpOMX : public BpInterface<IOMX> {
@@ -355,6 +362,105 @@ public:
         return err;
     }
 
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer) {
+
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeInt32((OMX_U32)virAddr);
+        data.writeInt32(size);
+        remote()->transact(USE_BUFFER2, data, &reply);
+
+        status_t err = reply.readInt32();
+        if (err != OK) {
+            *buffer = 0;
+
+            return err;
+        }
+
+        *buffer = (buffer_id)reply.readInt32();
+
+        return err;
+    }
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer) {
+
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeInt32((OMX_U32)virAddr);
+        data.writeInt32(size);
+        data.writeInt32(offset);
+        remote()->transact(USE_BUFFER3, data, &reply);
+
+        status_t err = reply.readInt32();
+        if (err != OK) {
+            *buffer = 0;
+
+            return err;
+        }
+
+        *buffer = (buffer_id)reply.readInt32();
+
+        return err;
+    }
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeStrongBinder(heap->asBinder());
+        remote()->transact(REGISTER_BUFFER, data, &reply);
+
+        return reply.readInt32();
+    }
+
+    virtual status_t registerBuffer2(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &HeapBase) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeStrongBinder(HeapBase->asBinder());
+        remote()->transact(REGISTER_BUFFER2, data, &reply);
+
+        return reply.readInt32();
+    }
+    virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeInt32((int32_t)node);
+        data.writeInt32(port_index);
+        data.writeInt32((OMX_U32)virAddr);
+        data.writeFileDescriptor((OMX_S32)fd);
+        data.writeInt32(size);
+        ALOGV("useIonBuffer writeFileDescriptor %x, %x, %x, %x, %x", node, port_index, virAddr, fd, size);
+        remote()->transact(USE_ION_BUFFER, data, &reply);
+
+        status_t err = reply.readInt32();
+        if (err != OK) {
+            *buffer = 0;
+
+            return err;
+        }
+
+        *buffer = (buffer_id)reply.readInt32();
+
+        return err;
+    }
+#endif
+
     virtual status_t prepareForAdaptivePlayback(
             node_id node, OMX_U32 port_index, OMX_BOOL enable,
             OMX_U32 max_width, OMX_U32 max_height) {
@@ -858,6 +964,96 @@ status_t BnOMX::onTransact(
 
             return NO_ERROR;
         }
+#ifdef MTK_HARDWARE
+        case USE_BUFFER2:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            unsigned char* virAddr = (unsigned char*)data.readInt32();
+            size_t size = data.readInt32();
+            buffer_id buffer;
+            status_t err = useBuffer(node, port_index, virAddr, size, &buffer);
+            reply->writeInt32(err);
+
+            if (err == OK) {
+                reply->writeInt32((int32_t)buffer);
+            }
+
+            return NO_ERROR;
+        }
+
+        case USE_BUFFER3:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            unsigned char* virAddr = (unsigned char*)data.readInt32();
+            size_t size = data.readInt32();
+            OMX_U32 offset = data.readInt32();
+            buffer_id buffer;
+            status_t err = useBuffer(node, port_index, virAddr, size, offset, &buffer);
+            reply->writeInt32(err);
+
+            if (err == OK) {
+                reply->writeInt32((int32_t)buffer);
+            }
+
+            return NO_ERROR;
+        }
+
+        case REGISTER_BUFFER:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            sp<IMemoryHeap> heap =
+                interface_cast<IMemoryHeap>(data.readStrongBinder());
+
+            status_t err = registerBuffer(node, port_index, heap);
+            reply->writeInt32(err);
+
+            return NO_ERROR;
+        }
+
+    case REGISTER_BUFFER2:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            sp<IMemoryHeap> HeapBase =
+                interface_cast<IMemoryHeap>(data.readStrongBinder());
+
+            status_t err = registerBuffer2(node, port_index, HeapBase);
+            reply->writeInt32(err);
+
+            return NO_ERROR;
+        }
+        case USE_ION_BUFFER:
+        {
+            CHECK_OMX_INTERFACE(IOMX, data, reply);
+            node_id node = (node_id)data.readInt32();
+            OMX_U32 port_index = data.readInt32();
+            unsigned char* virAddr = (unsigned char*)data.readInt32();
+            OMX_S32 fd = dup(data.readFileDescriptor());
+            size_t size = data.readInt32();
+            ALOGV("useIonBuffer readFileDescriptor %x, %x, %x, %x, %x", node, port_index, virAddr, fd, size);
+            buffer_id buffer;
+            status_t err = useIonBuffer(
+                    node, port_index, virAddr, fd, size, &buffer);
+            reply->writeInt32(err);
+
+            if (err == OK) {
+                reply->writeInt32((int32_t)buffer);
+            }
+
+            return NO_ERROR;
+        }
+#endif
 
         case PREPARE_FOR_ADAPTIVE_PLAYBACK:
         {
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 4be85bb5c..c96f18e5d 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -56,9 +56,14 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/native/include/media/openmax                  \
     $(TOP)/external/tremolo/Tremolo                                 \
 
-# Mediatek
-ifeq ($(strip $(BOARD_HAS_MTK_HARDWARE)),true)
-LOCAL_SHARED_LIBRARIES += libmtkplayer
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    LOCAL_C_INCLUDES += \
+     $(TOP)/mediatek/kernel/include/linux/vcodec \
+     $(TOP)/mediatek/frameworks-ext/av/media/libstagefright/include    \
+
+LOCAL_SHARED_LIBRARIES += \
+		libvcodecdrv \
+	    libmtkplayer
 endif
 
 LOCAL_MODULE:= libmediaplayerservice
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 90d4a2544..cf9603757 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -64,6 +64,9 @@
 #include <media/stagefright/FMA2DPWriter.h>
 #include <QCMediaDefs.h>
 #endif
+#ifdef MTK_HARDWARE
+#include "venc_drv_if.h" // for MCI buffer 
+#endif
 
 #include "ARTPWriter.h"
 #include <cutils/properties.h>
@@ -93,6 +96,14 @@ StagefrightRecorder::StagefrightRecorder()
       mRecPaused(false) {
 
     ALOGV("Constructor");
+#ifdef MTK_HARDWARE
+	mCamMemInfo = NULL;
+	mCamMemIonInfo = NULL;
+	//for MCI buffer
+	mCamMCIMemInfo = NULL;
+	mSupportMCIbuffer = false;
+	mpLivePhotoSource = NULL;
+#endif
     reset();
 
     mRecorderExtendedStats = (RecorderExtendedStats *)ExtendedStats::Create(
@@ -101,6 +112,30 @@ StagefrightRecorder::StagefrightRecorder()
 
 StagefrightRecorder::~StagefrightRecorder() {
     ALOGV("Destructor");
+#ifdef MTK_HARDWARE
+	if (mCamMemInfo != NULL)
+	{
+		free(mCamMemInfo);
+		mCamMemInfo = NULL;
+	}
+	if(mCamMemIonInfo != NULL)
+	{
+		free(mCamMemIonInfo);
+		mCamMemIonInfo = NULL;
+	}
+	if(mCamMCIMemInfo != NULL)
+	{
+		free(mCamMCIMemInfo);
+		mCamMCIMemInfo = NULL;
+	}
+/*	
+	if( mSurfaceMediaSource!= NULL && mStarted) {
+		ALOGD("call SurfaceMediaSource binderDied in ~StagefrightRecorder +");
+		mSurfaceMediaSource->binderDied();
+		ALOGD("call SurfaceMediaSource binderDied in ~StagefrightRecorder -");
+	}
+*/
+#endif
     stop();
 
     if (mLooper != NULL) {
@@ -236,7 +271,15 @@ status_t StagefrightRecorder::setVideoEncoder(video_encoder ve) {
         return BAD_VALUE;
     }
 
-    mVideoEncoder = ve;
+    if (ve == VIDEO_ENCODER_DEFAULT) {
+#ifdef MTK_HARDWARE //In order to pass CTS test case for preview size: 320 x 240
+        mVideoEncoder = VIDEO_ENCODER_MPEG_4_SP;
+#else
+        mVideoEncoder = VIDEO_ENCODER_H263;
+#endif
+    } else {
+        mVideoEncoder = ve;
+    }
 
     return OK;
 }
@@ -1672,8 +1715,127 @@ status_t StagefrightRecorder::setupVideoEncoder(
         CHECK(meta->findInt32(kKeySliceHeight, &sliceHeight));
         CHECK(meta->findInt32(kKeyColorFormat, &colorFormat));
 
+#ifdef MTK_HARDWARE
+    if (mVideoSource == VIDEO_SOURCE_CAMERA) {   // for live effect recording
+		int32_t iCamMemMode = -1;
+		int32_t camMemSize, camMemCount;
+		CHECK(meta->findInt32(kKeyCamMemSize, &camMemSize));
+		CHECK(meta->findInt32(kKeyCamMemCount, &camMemCount));
+		CHECK(meta->findInt32(kKeyCamMemMode, &iCamMemMode));
+		
+		format->setInt32("CMMd",iCamMemMode);
+
+		//for MCI buffer
+		if(mCamMCIMemInfo == NULL)
+			mCamMCIMemInfo= malloc(sizeof(CamMCIMemInfo_t));
+
+		CamMCIMemInfo_t* camMCIMemInfo = (CamMCIMemInfo_t*)mCamMCIMemInfo;
+		memset(camMCIMemInfo, 0, sizeof(CamMCIMemInfo_t));
+
+		meta->findInt32(kKeyCamMCIMemSecurity,(int32_t*)&(camMCIMemInfo->u4Security));
+		meta->findInt32(kKeyCamMCIMemCoherent,(int32_t*)&(camMCIMemInfo->u4Coherent));
+		format->setPointer("CMCI",mCamMCIMemInfo);	
+		
+		if(iCamMemMode == CAMERA_CONTINUOUS_MEM_MODE){
+			
+			int32_t camMemVa;
+			CHECK(meta->findInt32(kKeyCamMemVa, &camMemVa));
+			
+			if (mCamMemInfo == NULL) {
+				mCamMemInfo = malloc(sizeof(CamMemInfo_t));
+			}
+			CamMemInfo_t *camMemInfo = (CamMemInfo_t *)mCamMemInfo;
+			memset(camMemInfo, 0, sizeof(CamMemInfo_t));
+			camMemInfo->u4VdoBufCount = camMemCount;
+			camMemInfo->u4VdoBufSize = camMemSize;
+			ALOGD("camMemInfo.u4VdoBufCount=%d, camMemInfo.u4VdoBufSize=%d", camMemInfo->u4VdoBufCount, camMemInfo->u4VdoBufSize);
+
+			for (uint32_t i = 0; i < camMemInfo->u4VdoBufCount; i++)
+			{
+				camMemInfo->u4VdoBufVA[i] = camMemVa + camMemSize * i;//VA is continous
+				ALOGD("camMemInfo.u4VdoBufVA[%d]=%d", i, camMemInfo->u4VdoBufVA[i]);
+			}
+			format->setInt32("CMCI", (uint32_t)camMemInfo);
+		}
+		else if(iCamMemMode == CAMERA_DISCONTINUOUS_MEM_VA_MODE){
+		 	//VA directly
+
+			if (mCamMemInfo == NULL) {
+				mCamMemInfo = malloc(sizeof(CamMemInfo_t));
+			}
+			CamMemInfo_t *camMemInfo = (CamMemInfo_t *)mCamMemInfo;
+			memset(camMemInfo, 0, sizeof(CamMemInfo_t));
+
+			camMemInfo->u4VdoBufCount = camMemCount;
+			camMemInfo->u4VdoBufSize = camMemSize;
+					
+			void * pTempCamMemVaArray = NULL;
+			uint32_t* pCamMemVaArray = NULL;
+			if(meta->findPointer(kKeyCamMemVaArray,&pTempCamMemVaArray) && pTempCamMemVaArray){
+				pCamMemVaArray = (uint32_t*)pTempCamMemVaArray;
+				for(int i = 0; i < camMemCount; i++){
+					camMemInfo->u4VdoBufVA[i] = pCamMemVaArray[i];
+					ALOGD("camMemInfo.u4VdoBufVA[%d]=%d", i, camMemInfo->u4VdoBufVA[i]);
+				}
+			}
+			format->setInt32("CMCI", (uint32_t)camMemInfo);
+				
+		}
+		else if(iCamMemMode == CAMERA_DISCONTINUOUS_MEM_ION_MODE){ //ION Buffer 
+		
+			ALOGI("Camera Memory is allocated by ION");
+			if (mCamMemIonInfo == NULL) {
+				mCamMemIonInfo = malloc(sizeof(CamMemIonInfo_t));
+			}
+			CamMemIonInfo_t *camMemIonInfo = (CamMemIonInfo_t *)mCamMemIonInfo;
+			memset(camMemIonInfo, 0, sizeof(CamMemIonInfo_t));
+
+			camMemIonInfo->u4VdoBufCount = camMemCount;
+			camMemIonInfo->u4VdoBufSize = camMemSize;
+			
+			uint32_t* pCamMemIonFdArray = NULL;
+			if(meta->findPointer(kKeyCamMemIonFdArray,(void **)&pCamMemIonFdArray) && pCamMemIonFdArray){
+				for(int i = 0; i < camMemCount;i++){
+					camMemIonInfo->IonFd[i] = pCamMemIonFdArray[i];
+					ALOGD("camMemIonInfo.IonFd[%d]=%d", i, camMemIonInfo->IonFd[i]);
+				}
+			}
+
+			void * pTempCamMemVaArray = NULL;
+			uint32_t* pCamMemVaArray = NULL;
+			if(meta->findPointer(kKeyCamMemVaArray,&pTempCamMemVaArray) && pTempCamMemVaArray){
+				pCamMemVaArray = (uint32_t*)pTempCamMemVaArray;
+				for(int i = 0; i < camMemCount; i++){
+					camMemIonInfo->u4VdoBufVA[i] = pCamMemVaArray[i];
+					ALOGD("camMemIonInfo.u4VdoBufVA[%d]=%d", i, camMemIonInfo->u4VdoBufVA[i]);
+				}
+			}
+			
+			format->setInt32("CMCI", (uint32_t)camMemIonInfo);
+			
+		}
+		else{
+			ALOGW("kKeyCamMemMode is not support!");
+			return UNKNOWN_ERROR;
+		}
+				
+    }
+	//transfer coloreffect to codec
+	//codec can adjust initial Qp for special color effect such as whiteboard/blackboard
+	const char* colorEffect;
+	if(meta->findCString(kKeyColorEffect,&colorEffect)) {
+		format->setString("CoEf",colorEffect);
+	}
+#endif
+
+#ifdef MTK_HARDWARE
+    //tell codec the real width and height ap want to record
+    format->setInt32("width", mVideoWidth);
+    format->setInt32("height", mVideoHeight);
+#else
         format->setInt32("width", width);
         format->setInt32("height", height);
+#endif
         format->setInt32("stride", stride);
         format->setInt32("slice-height", sliceHeight);
         format->setInt32("color-format", colorFormat);
@@ -2004,7 +2166,11 @@ status_t StagefrightRecorder::reset() {
     // Default parameters
     mOutputFormat  = OUTPUT_FORMAT_THREE_GPP;
     mAudioEncoder  = AUDIO_ENCODER_AMR_NB;
+#ifdef MTK_HARDWARE    //In order to pass CTS test case for preview size: 320 x 240
+    mVideoEncoder  = VIDEO_ENCODER_MPEG_4_SP;
+#else
     mVideoEncoder  = VIDEO_ENCODER_DEFAULT;
+#endif
     mVideoWidth    = 176;
     mVideoHeight   = 144;
     mFrameRate     = -1;
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 527b64517..0157d3828 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -34,6 +34,10 @@
     } \
     while(0)
 
+#ifdef MTK_HARDWARE
+#include <LivePhotoSource.h>
+#include <media/stagefright/MetaData.h>
+#endif
 namespace android {
 
 class Camera;
@@ -153,6 +157,22 @@ private:
     status_t setupRawAudioRecording();
     status_t setupRTPRecording();
     status_t setupMPEG2TSRecording();
+#ifdef MTK_HARDWARE
+    String8 mRTPTarget;
+	void *mCamMemInfo;
+	void *mCamMemIonInfo;
+	void *mCamMCIMemInfo;
+	bool mSupportMCIbuffer;
+	bool mPaused;
+	String8 mArtistTag;
+	String8 mAlbumTag;
+
+	//for CTS VR parameter 1920*1080 which not 16 align
+	Size mVideoBufSizeLimit;
+	sp<LivePhotoSource> mpLivePhotoSource;
+	bool mEnableLivePhoto;
+	int32_t mLivePhotoTagValue;
+#endif
     sp<MediaSource> createAudioSource();
     status_t checkVideoEncoderCapabilities(
             bool *supportsCameraSourceMetaDataMode);
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index cdeb161f7..fcf2218d7 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -111,6 +111,17 @@
 #include <stagefright/Utils.h>
 #endif
 
+#ifdef MTK_HARDWARE
+#include <cutils/properties.h>
+#include <utils/CallStack.h> //Callstack
+#include "DpBlitStream.h"
+
+#define ENABLE_MTK_BUF_ADDR_ALIGNMENT
+#define MTK_BUF_ADDR_ALIGNMENT_VALUE 512
+
+#define ROUND_16(X)     ((X + 0xF) & (~0xF))
+#endif
+
 namespace android {
 
 // OMX errors are directly mapped into status_t range if
@@ -465,6 +476,19 @@ private:
 ACodec::ACodec()
     : mQuirks(0),
       mNode(0),
+#ifdef MTK_HARDWARE
+      mSupportsPartialFrames(false),
+      mLeftOverBuffer(NULL),
+      mMaxQueueBufferNum(-1),
+      mDumpFile(NULL),
+      mIsDumpFile(false),
+      mIsVideoDecoder(false),
+      mIsVideoEncoder(false),
+      mIsVideoEncoderInputSurface(0),
+      mVideoAspectRatioWidth(1),
+      mVideoAspectRatioHeight(1),
+      mIsDemandNormalYUV(false),
+#endif
       mSentFormat(false),
       mIsEncoder(false),
       mUseMetadataOnEncoderOutput(false),
@@ -588,6 +612,24 @@ void ACodec::signalSubmitOutputMetaDataBufferIfEOS_workaround() {
     }
 }
 
+#ifdef MTK_HARDWARE
+void ACodec::signalVEncIInterval(int seconds) {
+    sp<AMessage> msg = new AMessage(kWhatMtkVEncIFrameInterval, id());
+    msg->setInt32("MtkVEncIRate", seconds);
+    msg->post();
+}
+void ACodec::signalVEncBitRate(int bitrate) {
+    sp<AMessage> msg = new AMessage(kWhatMtkVEncBitRate, id());
+    msg->setInt32("MtkVEncBitRate", bitrate);
+    msg->post();
+}
+void ACodec::signalVEncFrameRate(int framerate) {
+    sp<AMessage> msg = new AMessage(kWhatMtkVEncFrameRate, id());
+    msg->setInt32("MtkVEncFrameRate", framerate);
+    msg->post();
+}
+#endif
+
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     ATRACE_NAME(mComponentName.c_str());
 
@@ -618,26 +660,26 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
         if (err == OK) {
+#if defined(MTK_HARDWARE) && defined(ENABLE_MTK_BUF_ADDR_ALIGNMENT)
+            def.nBufferSize = ((def.nBufferSize + MTK_BUF_ADDR_ALIGNMENT_VALUE-1) & ~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+#endif
             ALOGV("[%s] Allocating %u buffers of size %u on %s port",
                     mComponentName.c_str(),
                     def.nBufferCountActual, def.nBufferSize,
                     portIndex == kPortIndexInput ? "input" : "output");
 
-#ifdef MTK_HARDWARE
-            OMX_U32 memoryAlign = 32;
-            size_t totalSize = def.nBufferCountActual *
-                ((def.nBufferSize + (memoryAlign - 1))&(~(memoryAlign - 1)));
-#else
             size_t totalSize = def.nBufferCountActual * def.nBufferSize;
+#if defined(MTK_HARDWARE) && defined(ENABLE_MTK_BUF_ADDR_ALIGNMENT)
+            totalSize = def.nBufferCountActual * (((def.nBufferSize + MTK_BUF_ADDR_ALIGNMENT_VALUE-1) & ~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1)) + MTK_BUF_ADDR_ALIGNMENT_VALUE);
 #endif
             mDealer[portIndex] = new MemoryDealer(totalSize, "ACodec");
 
             for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
-                sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
+                sp<IMemory> mem = NULL;
+                mem = mDealer[portIndex]->allocate(def.nBufferSize);
                 if (mem == NULL || mem->pointer() == NULL) {
                     return NO_MEMORY;
                 }
-
                 BufferInfo info;
                 info.mStatus = BufferInfo::OWNED_BY_US;
 
@@ -667,7 +709,14 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                 }
 
                 if (mem != NULL) {
+#if defined(MTK_HARDWARE) && defined(ENABLE_MTK_BUF_ADDR_ALIGNMENT)
+                    OMX_U8 *ptr = static_cast<OMX_U8 *>(mem->pointer());
+                    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr)+(MTK_BUF_ADDR_ALIGNMENT_VALUE-1))&~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+                    info.mData = new ABuffer((void*)pBuffer, def.nBufferSize);
+                    ALOGD("@debug: Buffer[%d], %p(%p)", i, info.mData->data(), ptr);
+#else
                     info.mData = new ABuffer(mem->pointer(), def.nBufferSize);
+#endif
                 }
 
                 mBuffers[portIndex].push(info);
@@ -712,34 +761,32 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         return err;
     }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
-    setNativeWindowColorFormat(eNativeColorFormat);
-
-    err = native_window_set_buffers_geometry(
-    mNativeWindow.get(),
-    def.format.video.nFrameWidth,
-    def.format.video.nFrameHeight,
-    eNativeColorFormat);
-#elif defined(MTK_HARDWARE)
-    OMX_U32 frameWidth = def.format.video.nFrameWidth;
-    OMX_U32 frameHeight = def.format.video.nFrameHeight;
-
-    if (!strncmp("OMX.MTK.", mComponentName.c_str(), 8)) {
-        frameWidth = def.format.video.nStride;
-        frameHeight = def.format.video.nSliceHeight;
+#ifdef MTK_HARDWARE
+// mtk color/pixel formats for JB blob
+        uint32_t eHalColorFormat;
+       switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatVendorMTKYUV:
+            eHalColorFormat = HAL_PIXEL_FORMAT_NV12_BLK;
+            break;
+        default:
+            eHalColorFormat = HAL_PIXEL_FORMAT_I420;
+            break;           
     }
+        ALOGD ("native_window_set_buffers_geometry err(%x), W(%d), H(%d), Stride(%d), SliceH(%d)", err, def.format.video.nFrameWidth, def.format.video.nFrameHeight, def.format.video.nStride, def.format.video.nSliceHeight);
+#endif
 
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
-            frameWidth,
-            frameHeight,
-            def.format.video.eColorFormat);
+#ifdef MTK_HARDWARE
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
 #else
-    err = native_window_set_buffers_geometry(
-            mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#endif
+#ifdef MTK_HARDWARE
+            eHalColorFormat);
+#else
             def.format.video.eColorFormat);
 #endif
 
@@ -850,6 +897,14 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         return err;
     }
 
+#if defined(QCOM_HARDWARE) || defined(MTK_HARDWARE)
+    //add an extra buffer to display queue to get around dequeue+wait
+    //blocking too long (more than 1 Vsync) in case BufferQeuue is in
+    //sync-mode and advertizes only 1 buffer
+    (*minUndequeuedBuffers)++;
+    ALOGI("NOTE: Overriding minUndequeuedBuffers to %lu",*minUndequeuedBuffers);
+#endif
+
     // FIXME: assume that surface is controlled by app (native window
     // returns the number for the case when surface is not controlled by app)
     // FIXME2: This means that minUndeqeueudBufs can be 1 larger than reported
@@ -1076,11 +1131,21 @@ status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     int err = mNativeWindow->cancelBuffer(
         mNativeWindow.get(), info->mGraphicBuffer.get(), -1);
 
+#ifdef MTK_HARDWARE
+    if (err != 0) {
+        ALOGE("failed to cancel buffer from native window: %p, err = %d", mNativeWindow.get(), err);
+        info->mStatus = BufferInfo::OWNED_BY_UNEXPECTED;
+    } else {
+#endif
+
     ALOGW_IF(err != 0, "[%s] can not return buffer %u to native window",
             mComponentName.c_str(), info->mBufferID);
 
     info->mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;
 
+#ifdef MTK_HARDWARE
+    }
+#endif
     return err;
 }
 
@@ -1154,7 +1219,14 @@ ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
         return oldest;
     }
 
+#ifdef MTK_HARDWARE
+    ALOGI("dequeue buffer from native window (%p), but not matched in %d output buffers",
+           mNativeWindow.get(), mBuffers[kPortIndexOutput].size(), mNativeWindow.get());
+    int err = mNativeWindow->cancelBuffer(mNativeWindow.get(), buf, -1); 
+    ALOGI("\t\tcancel this unexpected buffer from native window, err = %d", err);
+#else
     TRESPASS();
+#endif
 
     return NULL;
 }
@@ -1164,8 +1236,15 @@ status_t ACodec::freeBuffersOnPort(OMX_U32 portIndex) {
         CHECK_EQ((status_t)OK, freeBuffer(portIndex, i));
     }
 
-    mDealer[portIndex].clear();
+#ifdef MTK_HARDWARE
+    if((portIndex == kPortIndexInput) && (!strncmp("OMX.MTK.VIDEO.DECODER.", mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mIsDemandNormalYUV==true))
+    {
 
+    mDealer[portIndex].clear();
+    }
+#else
+    mDealer[portIndex].clear();
+#endif
     return OK;
 }
 
@@ -1473,6 +1552,17 @@ status_t ACodec::configureCodec(
     bool haveNativeWindow = msg->findObject("native-window", &obj)
             && obj != NULL && video && !encoder;
     mStoreMetaDataInOutputBuffers = false;
+#ifdef MTK_HARDWARE
+    //move from mediacodec to acodec
+    if (!strncasecmp("video/", mime, 6))
+    {
+        if ( (obj == NULL) && (!encoder) ) {
+            //demandNormalYUV = false;
+            mIsDemandNormalYUV = true;
+            ALOGD("offer NormalYUV for JAVA framework enabled");
+        }
+    }
+#endif
     if (video && !encoder) {
         inputFormat->setInt32("adaptive-playback", false);
 
@@ -1802,6 +1892,12 @@ status_t ACodec::configureCodec(
             if (!msg->findInt32("aac-profile", &aacProfile)) {
                 aacProfile = OMX_AUDIO_AACObjectNull;
             }
+#ifndef ANDROID_DEFAULT_CODE
+            if (!msg->findInt32("bitrate", &bitRate)) {
+                bitRate = 0;
+                ALOGE("cannot find aac bit rate");
+            }
+#endif //ANDROID_DEFAULT_CODE
             if (!msg->findInt32("aac-sbr-mode", &sbrMode)) {
                 sbrMode = -1;
             }
@@ -1973,6 +2069,74 @@ status_t ACodec::configureCodec(
     mInputFormat = inputFormat;
     mOutputFormat = outputFormat;
 
+#ifdef MTK_HARDWARE
+    if ((!strncmp("OMX.MTK.", mComponentName.c_str(), 8)) && (!mIsEncoder)) {
+        OMX_BOOL value;
+        // check if codec supports partial frames input
+        status_t err = mOMX->getParameter(mNode, 
+                (OMX_INDEXTYPE)OMX_IndexVendorMtkOmxPartialFrameQuerySupported, 
+                &value, sizeof(value));
+        mSupportsPartialFrames = value;
+        if (err != OK) {
+            mSupportsPartialFrames = false;
+        }
+        ALOGI("mSupportsPartialFrames %d err %d ", mSupportsPartialFrames, err);
+    }
+
+    // mtk80902: porting rtsp settings from OMXCodec
+    int32_t mode;
+    if (msg->findInt32("rtsp-seek-mode", &mode) && mode != 0) {
+        status_t err2 = OK;
+        OMX_INDEXTYPE index = OMX_IndexMax;
+        status_t err = mOMX->getExtensionIndex(mNode, "OMX.MTK.index.param.video.StreamingMode", &index);
+        if (err == OK) {
+            OMX_BOOL m = OMX_TRUE; 
+            err2 = mOMX->setParameter(mNode, index, &m, sizeof(m));
+        }
+        ALOGI("set StreamingMode, index = %x, err = %x, err2 = %x", index, err, err2);
+    }
+    int32_t number = -1;
+    if (msg->findInt32("max-queue-buffer", &number) && number > 0) {
+        mMaxQueueBufferNum = number;
+    }
+    if (msg->findInt32("input-buffer-number", &number) && number > 0) {
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexInput;
+
+        status_t err = mOMX->getParameter(
+        mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ((int)err, (int)OK);
+
+        def.nBufferCountActual = number > (int32_t)def.nBufferCountMin 
+            ? number : def.nBufferCountMin;
+
+        err = mOMX->setParameter(
+        mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ((int)err, (int)OK);
+
+        err = mOMX->getParameter(
+        mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ((int)err, (int)OK);
+    }
+// mtk80902: porting from OMXCodec - is video enc/dec
+    if (false == mIsEncoder) {
+        if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) ||
+#ifdef MTK_HARDWARE
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP9, mime)) ||            
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VPX, mime))
+#endif
+        ) { 
+            mIsVideoDecoder = true;
+        }
+
+
+    }
+#endif
+
     return err;
 }
 
@@ -2597,6 +2761,9 @@ static const struct VideoCodingMapEntry {
     { MEDIA_MIMETYPE_VIDEO_MPEG2, OMX_VIDEO_CodingMPEG2 },
     { MEDIA_MIMETYPE_VIDEO_VP8, OMX_VIDEO_CodingVP8 },
     { MEDIA_MIMETYPE_VIDEO_VP9, OMX_VIDEO_CodingVP9 },
+#ifdef MTK_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_VPX, OMX_VIDEO_CodingVP8 },
+#endif
 };
 
 static status_t GetVideoCodingTypeFromMime(
@@ -2759,17 +2926,53 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
         stride = width;
     }
 
+/*it can be remove after ap set this parameters
+    @hide
+    public static final String KEY_STRIDE = "stride";
+*/
+#ifdef MTK_HARDWARE
+    video_def->nStride = ROUND_16(stride);
+#else
     video_def->nStride = stride;
+#endif
 
     int32_t sliceHeight;
     if (!msg->findInt32("slice-height", &sliceHeight)) {
         sliceHeight = height;
     }
 
+/*it can be remove after ap set this parameters
+    @hide
+    public static final String KEY_SLICE_HEIGHT = "slice-height";
+*/
+#ifdef MTK_HARDWARE
+    video_def->nSliceHeight = ROUND_16(sliceHeight);
+#else
     video_def->nSliceHeight = sliceHeight;
+#endif
 
+#ifdef MTK_HARDWARE
+    if( colorFormat == OMX_COLOR_Format16bitRGB565 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 2);
+    else if( colorFormat == OMX_COLOR_Format24bitRGB888 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3);
+    else if( colorFormat == OMX_COLOR_Format32bitARGB8888 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 4);
+    else
+    def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3) / 2;
+#else
     def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3) / 2;
+#endif
 
+#ifdef MTK_HARDWARE
+     {
+         int32_t  inputbufferCnt;
+         if (msg->findInt32("inputbuffercnt", &inputbufferCnt)) {
+            def.nBufferCountActual  = inputbufferCnt;
+            ALOGI("input buffer count is %d", inputbufferCnt);
+         }
+     }
+#endif
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
         int32_t tmp;
@@ -2845,6 +3048,15 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     video_def->eCompressionFormat = compressionFormat;
     video_def->eColorFormat = OMX_COLOR_FormatUnused;
 
+#ifdef MTK_HARDWARE
+     {
+         int32_t  outputbuffersize;
+         if (msg->findInt32("outputbuffersize", &outputbuffersize)) {
+            def.nBufferSize  = outputbuffersize;
+            ALOGI("output buffer size is %d", outputbuffersize);
+         }
+     }
+#endif
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -3264,6 +3476,12 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
     if (err != OK) {
         return err;
     }
+#ifdef MTK_HARDWARE
+    err = setVEncIInterval(iFrameInterval);
+    if (err != OK) {
+        return err;
+    }
+#endif
 
     return configureBitrate(bitrate, bitrateMode);
 }
@@ -3466,8 +3684,8 @@ status_t ACodec::setupErrorCorrectionParameters() {
     }
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
-    errorCorrectionType.bEnableResync = OMX_FALSE;
-    errorCorrectionType.nResynchMarkerSpacing = 0;
+    errorCorrectionType.bEnableResync = OMX_TRUE;
+    errorCorrectionType.nResynchMarkerSpacing = 256;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
@@ -3803,7 +4021,12 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("stride", videoDef->nStride);
                     notify->setInt32("slice-height", videoDef->nSliceHeight);
                     notify->setInt32("color-format", videoDef->eColorFormat);
-
+#ifdef MTK_HARDWARE
+            notify->setInt32("width-ratio", mVideoAspectRatioWidth);
+            notify->setInt32("height-ratio", mVideoAspectRatioHeight);
+            ALOGD("OMXCodec:: w %d, h %d, s %d, sh %d, cf %x", videoDef->nFrameWidth, videoDef->nFrameHeight,
+            videoDef->nStride, videoDef->nSliceHeight, videoDef->eColorFormat);
+#endif
                     if (mNativeWindow == NULL) {
                         DescribeColorFormatParams describeParams;
                         InitOMXParams(&describeParams);
@@ -3850,6 +4073,26 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                         rect.nWidth = videoDef->nFrameWidth;
                         rect.nHeight = videoDef->nFrameHeight;
                     }
+#ifdef MTK_HARDWARE
+                if( OMX_COLOR_FormatYUV420Planar != videoDef->eColorFormat )
+                {
+                    //adjust stride and sliceheight for color convert output is base on width and height
+                    if( (OMX_COLOR_FormatVendorMTKYUV == videoDef->eColorFormat) || (OMX_MTK_COLOR_FormatYV12== videoDef->eColorFormat) )
+                    {
+                        // In CTS EncodeDecodeTest.java, we may disable this format update
+                        //private boolean checkFrame(int frameIndex, MediaFormat format, ByteBuffer frameData) {
+                        // Check for color formats we don't understand.  There is no requirement for video
+                        // decoders to use a "mundane" format, so we just give a pass on proprietary formats.
+                        notify->setInt32("stride", videoDef->nFrameWidth);
+                        notify->setInt32("slice-height", videoDef->nFrameHeight);
+                        //disable temporary for KK CTS decoderTest EOSBehavior
+                        notify->setInt32("color-format", OMX_COLOR_FormatYUV420Planar);
+                        ALOGD("Update output width %d, height %d, stride %d, slice-height %d", videoDef->nFrameWidth, 
+                            videoDef->nFrameHeight, videoDef->nStride, videoDef->nSliceHeight);
+                        ALOGD("Update output format from %x to %x", videoDef->eColorFormat, OMX_COLOR_FormatYUV420Planar);
+                    }
+                }
+#endif
 
                     CHECK_GE(rect.nLeft, 0);
                     CHECK_GE(rect.nTop, 0);
@@ -4275,10 +4518,35 @@ void ACodec::signalError(OMX_ERRORTYPE error, status_t internalError) {
     }
 
     mFatalError = true;
+#ifdef MTK_HARDWARE
+// mtk80902: ALPS00442417 - porting error handler from OMXCodec
+    if(error == OMX_ErrorStreamCorrupt)
+    {                        
+        ALOGW("OMXCodec::onEvent--OMX Error Stream Corrupt!!");     
+        if(mIsVideoEncoder) {
+            ALOGW("OMXCodec::onEvent--Video encoder error");
+            notify->setInt32("err", ERROR_UNSUPPORTED_VIDEO);
+            notify->post();
+        }
+    } else if (mIsVideoDecoder && error == OMX_ErrorBadParameter) {
+        ALOGW("OMXCodec::onEvent--OMX Bad Parameter!!");
+        notify->setInt32("err", ERROR_UNSUPPORTED_VIDEO);
+        notify->post();
+    } else if (!mIsEncoder && !mIsVideoDecoder && error == OMX_ErrorBadParameter){
+        ALOGW("OMXCodec::onEvent--Audio OMX Bad Parameter!!");
+        notify->setInt32("err", ERROR_UNSUPPORTED_AUDIO);
+        notify->post();
+    } else {
+        ALOGW("OMXCodec::onEvent internalError %d", internalError);
+        notify->setInt32("err", internalError);
+        notify->post();
+    }
+#else
 
     notify->setInt32("err", internalError);
     notify->setInt32("actionCode", ACTION_CODE_FATAL); // could translate from OMX error.
     notify->post();
+#endif
 }
 
 status_t ACodec::pushBlankBuffersToNativeWindow() {
@@ -4435,6 +4703,32 @@ status_t ACodec::requestIDRFrame() {
         return ERROR_UNSUPPORTED;
     }
 
+#ifdef MTK_HARDWARE
+        if (!strncmp(mComponentName.c_str(), "OMX.MTK.", 8)) {
+	     ALOGI("request I frame");
+            OMX_INDEXTYPE index;
+            status_t err =
+            mOMX->getExtensionIndex(
+                    mNode,
+                    "OMX.MTK.index.param.video.EncSetForceIframe",
+                    &index);
+
+            if (err != OK) {
+                return err;
+            }
+
+            OMX_BOOL enable = OMX_TRUE;
+            err = mOMX->setConfig(mNode, index, &enable, sizeof(enable));
+
+            if (err != OK) {
+                ALOGE("setConfig('OMX.MTK.index.param.video.EncSetForceIframe') returned error 0x%08x", err);
+                return err;
+            }
+
+	    return OK;
+	}
+        else {
+	     ALOGI("request I frame - non MTK codec index(0x%08X)", OMX_IndexConfigVideoIntraVOPRefresh);
     OMX_CONFIG_INTRAREFRESHVOPTYPE params;
     InitOMXParams(&params);
 
@@ -4447,7 +4741,90 @@ status_t ACodec::requestIDRFrame() {
             &params,
             sizeof(params));
 }
+#else
+    OMX_CONFIG_INTRAREFRESHVOPTYPE params;
+    InitOMXParams(&params);
+
+    params.nPortIndex = kPortIndexOutput;
+    params.IntraRefreshVOP = OMX_TRUE;
+
+    return mOMX->setConfig(
+            mNode,
+            OMX_IndexConfigVideoIntraVOPRefresh,
+            &params,
+            sizeof(params));
+#endif
+
+}
+
+#ifdef MTK_HARDWARE
+status_t ACodec::setVEncIInterval(int seconds) {
+    if (!mIsEncoder) {
+        return ERROR_UNSUPPORTED;
+    }
+    if (!strncmp(mComponentName.c_str(), "OMX.MTK.VIDEO.ENCODER", 21)) {
+        ALOGI("set I frame rate");
+        OMX_INDEXTYPE index;
+        status_t err =
+        mOMX->getExtensionIndex(
+                mNode,
+                "OMX.MTK.index.param.video.EncSetIFrameRate",
+                &index);
+
+        if (err != OK) {
+            return err;
+        }
+
+        OMX_BOOL enable = OMX_TRUE;
+        err = mOMX->setConfig(mNode, index, &seconds, sizeof(seconds));
+
+        if (err != OK) {
+            ALOGE("setConfig('OMX.MTK.index.param.video.EncSetIFrameRate') returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
 
+status_t ACodec::setVEncBitRate(int bitrate) {
+    if (!mIsEncoder) {
+        return ERROR_UNSUPPORTED;
+    }
+    if (!strncmp(mComponentName.c_str(), "OMX.MTK.VIDEO.ENCODER", 21)) {
+        ALOGI("set bitrate");
+
+        OMX_BOOL enable = OMX_TRUE;
+        OMX_VIDEO_CONFIG_BITRATETYPE    bitrateType;
+        bitrateType.nEncodeBitrate = bitrate;
+        status_t err = mOMX->setConfig(mNode, OMX_IndexConfigVideoBitrate, &bitrateType, sizeof(bitrateType));
+
+        if (err != OK) {
+            ALOGE("setConfig(OMX_IndexConfigVideoBitrate) returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+status_t ACodec::setVEncFrameRate(int framerate) {
+    if (!mIsEncoder) {
+        return ERROR_UNSUPPORTED;
+    }
+    if (!strncmp(mComponentName.c_str(), "OMX.MTK.VIDEO.ENCODER", 21)) {
+        ALOGI("set framerate");
+
+        OMX_BOOL enable = OMX_TRUE;
+        OMX_CONFIG_FRAMERATETYPE    framerateType;
+        framerateType.xEncodeFramerate = framerate<<16;
+        status_t err = mOMX->setConfig(mNode, OMX_IndexConfigVideoFramerate, &framerateType, sizeof(framerateType));
+
+        if (err != OK) {
+            ALOGE("setConfig(OMX_IndexConfigVideoFramerate) returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+#endif
 void ACodec::PortDescription::addBuffer(
         IOMX::buffer_id id, const sp<ABuffer> &buffer) {
     mBufferIDs.push_back(id);
@@ -4655,6 +5032,24 @@ bool ACodec::BaseState::onOMXEmptyBufferDone(IOMX::buffer_id bufferID) {
             break;
 
         case RESUBMIT_BUFFERS:
+#ifdef MTK_HARDWARE
+            // mtk80902: porting from AwesomePlayer: prevent buffering twice
+            if (mCodec->mMaxQueueBufferNum > 0) {
+                size_t n = mCodec->mBuffers[kPortIndexInput].size();
+                size_t others = 0;
+                for (size_t i = 0; i < n; ++i) {
+                    BufferInfo *info = &mCodec->mBuffers[kPortIndexInput].editItemAt(i);
+                    if (info->mStatus == BufferInfo::OWNED_BY_COMPONENT)
+                        others++;
+                }
+
+                if (mCodec->mMaxQueueBufferNum < others) {
+                    ALOGV("mMaxQueueBufferNum %d < component occupied %d, wait for next trigger.",
+                    mCodec->mMaxQueueBufferNum, others);
+                    break;
+                }
+            }
+#endif
             postFillThisBuffer(info);
             break;
 
@@ -4676,11 +5071,41 @@ void ACodec::BaseState::postFillThisBuffer(BufferInfo *info) {
 
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
+#ifdef MTK_HARDWARE
+    if (mCodec->mLeftOverBuffer != NULL) {
+        ALOGD("[%s] left over buffer (id = %p)", 
+               mCodec->mComponentName.c_str(), info->mBufferID);
+        info->mData->meta()->clear();
+
+        sp<AMessage> reply = new AMessage(kWhatInputBufferFilled, mCodec->id());
+        reply->setInt32("buffer-id", info->mBufferID);
+        reply->setBuffer("buffer", mCodec->mLeftOverBuffer);
+        mCodec->mLeftOverBuffer = NULL;
+//        reply->setInt32("partial", 1);
+        reply->post();
+
+        info->mStatus = BufferInfo::OWNED_BY_UPSTREAM;
+        return;
+    }
+#endif
     sp<AMessage> notify = mCodec->mNotify->dup();
     notify->setInt32("what", CodecBase::kWhatFillThisBuffer);
     notify->setInt32("buffer-id", info->mBufferID);
 
+#ifdef MTK_HARDWARE
+   {
+            
+         void *mediaBuffer;
+         if(info->mData->meta()->findPointer("mediaBuffer", &mediaBuffer)
+                 && mediaBuffer != NULL){
+             //ALOGI("postFillThisBuffer release mediabuffer");
+             ((MediaBuffer *)mediaBuffer)->release();
+         }
+    info->mData->meta()->clear();
+    }
+#else
     info->mData->meta()->clear();
+#endif
     notify->setBuffer("buffer", info->mData);
 
     sp<AMessage> reply = new AMessage(kWhatInputBufferFilled, mCodec->id());
@@ -4728,6 +5153,31 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
 
     info->mStatus = BufferInfo::OWNED_BY_US;
 
+#ifdef MTK_HARDWARE
+    if ( (true == mCodec->mIsDumpFile ) && (buffer != NULL) ) {
+        int64_t tt;
+        int32_t isCSD = false;
+        buffer->meta()->findInt64("timeUs", &tt);
+        ALOGD("[%s]buffer to be empty, %lld, %p, size = %d", mCodec->mComponentName.c_str(), tt, buffer->data(), (int)buffer->size());
+        buffer->meta()->findInt32("csd", &isCSD) ;
+        if (buffer->size() >= 4) {
+            ALOGD("[%s]\t\t %s, %02x %02x %02x %02x", 
+                    mCodec->mComponentName.c_str(), 
+                    isCSD ? "codec_cfg":"", 
+                    buffer->data()[0], buffer->data()[1] , buffer->data()[2] , buffer->data()[3]);
+        }
+
+        if ((mCodec->mDumpFile != NULL) && 
+                (!strcmp(mCodec->mComponentName.c_str(), "OMX.MTK.VIDEO.DECODER.AVC"))) {
+            if (!isCSD) {
+                char nal_prefix[] = {0, 0, 0, 1};
+                fwrite(nal_prefix, 1, 4, mCodec->mDumpFile);
+            }
+            size_t nWrite = fwrite(buffer->data(), 1, buffer->size(), mCodec->mDumpFile);
+            ALOGD("written %d bytes, ftell = %d", nWrite, (int)ftell(mCodec->mDumpFile));
+        }
+    }
+#endif
     switch (mode) {
         case KEEP_BUFFERS:
         {
@@ -4762,8 +5212,36 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                          mCodec->mComponentName.c_str(),
                          bufferID,
                          buffer.get(), info->mData.get());
+#ifdef MTK_HARDWARE
+                    int capacity = info->mData->capacity();
+                    if (buffer->size() > capacity) {
+                        if (mCodec->mSupportsPartialFrames) {
+                            sp<ABuffer> leftBuffer = new ABuffer(buffer->size() - capacity);
+                            memcpy(leftBuffer->data(), buffer->data() + capacity, buffer->size() - capacity);
+                            leftBuffer->meta()->setInt64("timeUs", timeUs);
+                            if (isCSD) {
+                                leftBuffer->meta()->setInt32("csd", isCSD);
+                            }
 
+                            ALOGI("[%s] split big input buffer %d to %d + %d",
+                                    mCodec->mComponentName.c_str(),  buffer->size(), capacity, leftBuffer->size());
+
+                            buffer->setRange(buffer->offset(), capacity);
+                            flags &= ~OMX_BUFFERFLAG_ENDOFFRAME;
+
+                            mCodec->mLeftOverBuffer = leftBuffer;
+                        } else {
+                            ALOGE("Codec's input buffers are too small to accomodate "
+                                    " buffer read from source (info->mSize = %d, srcLength = %d)",
+                                    info->mData->capacity(), buffer->size());
+                            mCodec->signalError();
+                            break;
+                            //CHECK_LE(buffer->size(), info->mData->capacity());
+                        }
+                    }
+#else
                     CHECK_LE(buffer->size(), info->mData->capacity());
+#endif
                     memcpy(info->mData->data(), buffer->data(), buffer->size());
                 }
 
@@ -4919,6 +5397,10 @@ bool ACodec::BaseState::onOMXFillBufferDone(
     }
 #endif
 
+#ifdef MTK_HARDWARE
+    BufferInfo *infoOmx = NULL;
+    size_t mRangeLength = 0;
+#endif
     BufferInfo *info =
         mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
 
@@ -4935,16 +5417,60 @@ bool ACodec::BaseState::onOMXFillBufferDone(
 
         case RESUBMIT_BUFFERS:
         {
+
             if (rangeLength == 0 && (!(flags & OMX_BUFFERFLAG_EOS)
                     || mCodec->mPortEOS[kPortIndexOutput])) {
-                ALOGV("[%s] calling fillBuffer %u",
+#ifdef MTK_HARDWARE
+                //check OMX.MTK.VIDEO.DECODER. prefix for video decoder only
+                if((!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV==true))
+                {
+                    ALOGV("[%s] calling fillBuffer infoOmx %p",
+                         mCodec->mComponentName.c_str(), infoOmx->mBufferID);
+                    if (mCodec->mPortEOS[kPortIndexOutput])
+                    {//Bruce 2013/01/21 if after eos, we don't send fill_this_buffer again, or it may cause busy loop on Mtk Omx component
+                        ALOGE("Output already EOS!");
+                        break;
+                    }
+                    CHECK_EQ(mCodec->mOMX->fillBuffer(
+                                mCodec->mNode, infoOmx->mBufferID),
+                             (status_t)OK);
+                    
+                    infoOmx->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+                    info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+
+                }
+                else
+                {
+                ALOGV("[%s] calling fillBuffer %p",
                      mCodec->mComponentName.c_str(), info->mBufferID);
 
+                    if (mCodec->mPortEOS[kPortIndexOutput])
+                    {//Bruce 2013/01/21 if after eos, we don't send fill_this_buffer again, or it may cause busy loop on Mtk Omx component
+                        ALOGE("Output already EOS!");
+                        break;
+                    }
+                CHECK_EQ(mCodec->mOMX->fillBuffer(
+                            mCodec->mNode, info->mBufferID),
+                         (status_t)OK);
+
+                info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+                }
+#else
+                ALOGV("[%s] calling fillBuffer %u",
+                     mCodec->mComponentName.c_str(), info->mBufferID);
+#ifdef MTK_HARDWARE
+                if (mCodec->mPortEOS[kPortIndexOutput])
+                {//Bruce 2013/01/21 if after eos, we don't send fill_this_buffer again, or it may cause busy loop on Mtk Omx component
+                    ALOGE("Output already EOS!");
+                break;
+            }
+#endif
                 CHECK_EQ(mCodec->mOMX->fillBuffer(
                             mCodec->mNode, info->mBufferID),
                          (status_t)OK);
 
                 info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+#endif
                 break;
             }
 
@@ -4962,7 +5488,23 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                 info->mData->meta()->setInt32("rangeOffset", rangeOffset);
                 info->mData->meta()->setInt32("rangeLength", rangeLength);
             } else {
+#ifdef MTK_HARDWARE
+            //check OMX.MTK.VIDEO.DECODER. prefix for video decoder only
+            if( (!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV==true))
+            {
+                //for normal YUV, set rangeLength without specific alighments and update 0 size from FBD msg
+                if( rangeLength == 0 )
                 info->mData->setRange(rangeOffset, rangeLength);
+                else
+                    info->mData->setRange(rangeOffset, mRangeLength);
+                ALOGV("set rangeLength %d, modified mRangeLength %d", rangeLength, mRangeLength);
+            }
+            else
+                info->mData->setRange(rangeOffset, rangeLength);
+#else
+            info->mData->setRange(rangeOffset, rangeLength);
+
+#endif
             }
 #if 0
             if (mCodec->mNativeWindow == NULL) {
@@ -4990,6 +5532,13 @@ bool ACodec::BaseState::onOMXFillBufferDone(
 
             notify->post();
 
+#ifdef MTK_HARDWARE
+            //check OMX.MTK.VIDEO.DECODER. prefix for video decoder only
+            if( (!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV==true))
+            {
+                infoOmx->mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;
+            }
+#endif
             info->mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;
 
             if (flags & OMX_BUFFERFLAG_EOS) {
@@ -5021,11 +5570,89 @@ bool ACodec::BaseState::onOMXFillBufferDone(
 void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
     IOMX::buffer_id bufferID;
     CHECK(msg->findInt32("buffer-id", (int32_t*)&bufferID));
+#ifdef MTK_HARDWARE
+    ALOGV("onOutputBufferDrained bufferID %x", bufferID);
+
+    int64_t delayTimeUs; 
+    int64_t realTimeUs;
+    if( msg->findInt64("delaytimeus", &delayTimeUs) && msg->findInt64("realtimeus", &realTimeUs)) {
+        int64_t realDelayTimeUs = realTimeUs - ALooper::GetNowUs();
+
+        if (realDelayTimeUs > delayTimeUs) {
+            ALOGW("realDelayTimeUs(%lldus) is latger than delayTimeUs(%lldus), reset it to delayTimeUs", realDelayTimeUs, delayTimeUs);
+            realDelayTimeUs = delayTimeUs;
+        }
+
+        if(realDelayTimeUs > 0){
+            if(realDelayTimeUs < 5000)
+                ALOGW("realDelayTimeUs(%lld) is too small", realDelayTimeUs);
+            else if( realDelayTimeUs > 50000 )
+
+           {
+                ALOGW("realDelayTimeUs(%lld) is too long, config to 30ms", realDelayTimeUs);
+                realDelayTimeUs = 30000;
+            }
+            else
+                ALOGD("realDelayTimeUs(%lld)", realDelayTimeUs);
+
+            sp<AMessage> delay = new AMessage(kWhatOutputBufferDrained, mCodec->id());
+            int32_t render = 0;
+            android_native_rect_t mCrop;
+            OMX_CONFIG_RECTTYPE mRect;
+
+            msg->findInt32("render", &render);
+            if (msg->findRect("crop",
+                    &mCrop.left, &mCrop.top, &mCrop.right, &mCrop.bottom)) {
+
+                ALOGD("send native_window_set_crop again");
+                mRect.nLeft = mCrop.left;
+                mRect.nTop = mCrop.top;
+                mRect.nWidth = mCrop.right;
+                mRect.nHeight = mCrop.bottom;
+
+                delay->setRect(
+                        "crop",
+                        mRect.nLeft,
+                        mRect.nTop,
+                        mRect.nLeft + mRect.nWidth,
+                        mRect.nTop + mRect.nHeight);
+            }
+
+            delay->setInt32("render", render);
+            delay->setInt32("buffer-id", bufferID);
+            delay->post(realDelayTimeUs);
+            return;
+        }
+        else {
+            ALOGW("video buffer late, no need delay");
+        }
+    }
+
+    BufferInfo *infoOMX = NULL;
+    BufferInfo *info = NULL;
+    ssize_t index;
+    //check OMX.MTK.VIDEO.DECODER. prefix for video decoder only
+    if( (!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV==true))
+    {
+        ssize_t index_tmp;
+        //get bufferInfo from bufferID in convert component for JAVA 
+        info = mCodec->findBufferByID(kPortIndexOutput, bufferID, &index_tmp);
+        ALOGV("findBufferByID index_tmp %x", index_tmp);
+        //get bufferInfo from bufferID in OMX component
+        CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
+    }
+    else
+    {
+        info = mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
+        CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
+    }
+#else
     ssize_t index;
     BufferInfo *info =
         mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
 
+#endif
     android_native_rect_t crop;
     if (msg->findRect("crop",
             &crop.left, &crop.top, &crop.right, &crop.bottom)) {
@@ -5076,6 +5703,14 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
             info->mStatus = BufferInfo::OWNED_BY_US;
         }
     } else {
+#ifdef MTK_HARDWARE
+        //check OMX.MTK.VIDEO.DECODER. prefix for video decoder only
+        if((!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV==true))
+        {
+            if (infoOMX != NULL)
+                infoOMX->mStatus = BufferInfo::OWNED_BY_US;
+        }
+#endif
         if (mCodec->mNativeWindow != NULL
             && msg->findInt32("render", &render) && render == 0
             && (info->mData == NULL || info->mData->size() != 0)) {
@@ -5110,6 +5745,34 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
                     info = mCodec->dequeueBufferFromNativeWindow();
                 }
 
+#ifdef MTK_HARDWARE
+                //check OMX.MTK.VIDEO.DECODER. prefix for video decoder only
+                if((!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV==true))
+                {
+                if (info != NULL) {
+                    ALOGV("[%s] calling fillBuffer %p",
+                         mCodec->mComponentName.c_str(), info->mBufferID);
+
+                    CHECK_EQ(mCodec->mOMX->fillBuffer(mCodec->mNode, info->mBufferID),
+                             (status_t)OK);
+
+                    info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+                        if (infoOMX != NULL)
+                            infoOMX->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+                }
+            }
+                else
+                {
+                    if (info != NULL) {
+                        ALOGV("[%s] calling fillBuffer %p",
+                             mCodec->mComponentName.c_str(), info->mBufferID);
+                        CHECK_EQ(mCodec->mOMX->fillBuffer(mCodec->mNode, info->mBufferID),
+                                 (status_t)OK);
+
+                        info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
+                    }
+                }
+#else
                 if (info != NULL) {
                     ALOGV("[%s] calling fillBuffer %u",
                          mCodec->mComponentName.c_str(), info->mBufferID);
@@ -5119,6 +5782,7 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
 
                     info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
                 }
+#endif
             }
             break;
         }
@@ -5220,8 +5884,19 @@ bool ACodec::UninitializedState::onMessageReceived(const sp<AMessage> &msg) {
 
 void ACodec::UninitializedState::onSetup(
         const sp<AMessage> &msg) {
+#ifdef MTK_HARDWARE
+    int32_t bAutoRun = 1;
+    if (!msg->findInt32("auto-run", &bAutoRun)) {
+        bAutoRun = 1;        
+    }
+    ALOGD("auto run = %d", (int32_t)bAutoRun);
+#endif
     if (onAllocateComponent(msg)
-            && mCodec->mLoadedState->onConfigureComponent(msg)) {
+            && mCodec->mLoadedState->onConfigureComponent(msg)
+#ifdef MTK_HARDWARE
+            && (bAutoRun)
+#endif                                      
+    ) {
         mCodec->mLoadedState->onStart();
     }
 }
@@ -5367,6 +6042,9 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", CodecBase::kWhatComponentAllocated);
         notify->setString("componentName", mCodec->mComponentName.c_str());
+#ifdef MTK_HARDWARE
+	notify->setInt32("quirks", quirks);
+#endif
         notify->post();
     }
 
@@ -5512,6 +6190,27 @@ bool ACodec::LoadedState::onConfigureComponent(
                 return false;
             }
 
+#ifdef MTK_HARDWARE
+    {
+        int32_t dummy = 0;
+
+        char value[PROPERTY_VALUE_MAX];
+        property_get("acodec.video.isProtect", value, "0");
+        dummy = atof(value);
+        if (dummy > 0) {
+            mCodec->mFlags |= kFlagIsGrallocUsageProtected;
+            ALOGD ("acodec.video.isProtect %x", dummy);
+        }
+        //ALOGD ("mCodec->mFlags %x", mCodec->mFlags);
+
+        dummy = 0;
+        if( msg->findInt32("IsSecureVideo", &dummy)&& (dummy == 1) )
+        {
+            mCodec->mFlags |= kFlagIsGrallocUsageProtected;
+           ALOGD("@debug: mCodec->mFlags |= kFlagIsGrallocUsageProtected %x", mCodec->mFlags);
+        }
+    }
+#endif
             mCodec->mNode = NULL;
             AString componentName;
             sp<CodecObserver> observer = new CodecObserver;
@@ -5575,6 +6274,13 @@ bool ACodec::LoadedState::onConfigureComponent(
         CHECK(nativeWindow != NULL);
         mCodec->mNativeWindow = nativeWindow->getNativeWindow();
 
+#ifdef MTK_HARDWARE
+        ALOGD("@debug: native windows to set %p", mCodec->mNativeWindow.get());
+        if (mCodec->mNativeWindow.get() == NULL) {
+            ALOGD("onConfigureComponent: fail because native window is null");
+            return false;
+        }
+#endif
         native_window_set_scaling_mode(
                 mCodec->mNativeWindow.get(),
                 NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
@@ -5676,6 +6382,9 @@ void ACodec::LoadedState::onCreateInputSurface(
     if (err == OK) {
         notify->setObject("input-surface",
                 new BufferProducerWrapper(bufferProducer));
+#ifdef MTK_HARDWARE
+        mCodec->mIsVideoEncoderInputSurface = 1;
+#endif
     } else {
         // Can't use mCodec->signalError() here -- MediaCodec won't forward
         // the error through because it's in the "configured" state.  We
@@ -5976,6 +6685,12 @@ bool ACodec::ExecutingState::onMessageReceived(const sp<AMessage> &msg) {
 
             mActive = false;
 
+#ifdef MTK_HARDWARE
+            if (mCodec->mLeftOverBuffer != NULL) {
+                ALOGI("clear mLeftOverBuffer %x", mCodec->mLeftOverBuffer.get());
+                mCodec->mLeftOverBuffer = NULL;
+            }
+#endif
             CHECK_EQ(mCodec->mOMX->sendCommand(
                         mCodec->mNode, OMX_CommandFlush, OMX_ALL),
                      (status_t)OK);
@@ -6003,6 +6718,29 @@ bool ACodec::ExecutingState::onMessageReceived(const sp<AMessage> &msg) {
             handled = true;
             break;
         }
+#ifdef MTK_HARDWARE
+        case kWhatMtkVEncIFrameInterval:
+        {
+            int seconds;
+            msg->findInt32("MtkVEncIRate", &seconds);
+            status_t err = mCodec->setVEncIInterval(seconds);
+            break;
+        }
+        case kWhatMtkVEncBitRate:
+        {
+            int bitrate;
+            msg->findInt32("MtkVEncBitRate", &bitrate);
+            status_t err = mCodec->setVEncBitRate(bitrate);
+            break;
+        }
+        case kWhatMtkVEncFrameRate:
+        {
+            int framerate;
+            msg->findInt32("MtkVEncFrameRate", &framerate);
+            status_t err = mCodec->setVEncFrameRate(framerate);
+            break;
+        }
+#endif
 
         case kWhatSetParameters:
         {
@@ -6136,17 +6874,41 @@ bool ACodec::ExecutingState::onOMXEvent(
         {
             CHECK_EQ(data1, (OMX_U32)kPortIndexOutput);
 
+#ifdef MTK_HARDWARE
+            if (data2 == 0 || data2 == OMX_IndexParamPortDefinition || data2 == OMX_IndexVendorMtkOmxVdecGetAspectRatio) {
+#else
             if (data2 == 0 || data2 == OMX_IndexParamPortDefinition) {
+#endif
                 mCodec->mMetaDataBuffersToSubmit = 0;
                 CHECK_EQ(mCodec->mOMX->sendCommand(
                             mCodec->mNode,
                             OMX_CommandPortDisable, kPortIndexOutput),
                          (status_t)OK);
 
+#ifdef MTK_HARDWARE
+                if (data2 == OMX_IndexVendorMtkOmxVdecGetAspectRatio) {
+                    ALOGE ("@@ GOT OMX_IndexVendorMtkOmxVdecGetAspectRatio");
+                    OMX_S32 aspectRatio = 0;
+                    if (OK == mCodec->mOMX->getConfig(mCodec->mNode, OMX_IndexVendorMtkOmxVdecGetAspectRatio, &aspectRatio, sizeof(aspectRatio))) {
+                        ALOGE ("@@ AspectRatioWidth (%d), AspectRatioHeight(%d)", (aspectRatio & 0xFFFF0000) >> 16, (aspectRatio & 0x0000FFFF));
+                        mCodec->mVideoAspectRatioWidth = ((aspectRatio & 0xFFFF0000) >> 16);
+                        mCodec->mVideoAspectRatioHeight = (aspectRatio & 0x0000FFFF);
+                    }
+                }
+#endif
                 mCodec->freeOutputBuffersNotOwnedByComponent();
 
                 mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
 
+#ifdef MTK_HARDWARE
+                if (data2 == OMX_IndexVendorMtkOmxVdecGetAspectRatio) {
+
+                    sp<AMessage> reply =
+                        new AMessage(kWhatOutputBufferDrained, mCodec->id());
+                    mCodec->sendFormatChange(reply);
+                }
+#endif
+
                 bool isVideo = mCodec->mComponentName.find("video") != -1;
                 if (isVideo) {
                     CODEC_PLAYER_STATS(profileStart, STATS_PROFILE_RECONFIGURE);
@@ -6232,8 +6994,21 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
                 ALOGV("[%s] Output port now disabled.",
                         mCodec->mComponentName.c_str());
 
+#ifdef MTK_HARDWARE
+                if((!strncmp("OMX.MTK.VIDEO.DECODER.", mCodec->mComponentName.c_str(), strlen("OMX.MTK.VIDEO.DECODER."))) && (mCodec->mIsDemandNormalYUV == true))
+                {
+                CHECK(mCodec->mBuffers[kPortIndexOutput].isEmpty());
+                mCodec->mDealer[kPortIndexOutput].clear();
+                }
+                else
+                {
                 CHECK(mCodec->mBuffers[kPortIndexOutput].isEmpty());
                 mCodec->mDealer[kPortIndexOutput].clear();
+                }
+#else
+                CHECK(mCodec->mBuffers[kPortIndexOutput].isEmpty());
+                mCodec->mDealer[kPortIndexOutput].clear();
+#endif
 
                 CHECK_EQ(mCodec->mOMX->sendCommand(
                             mCodec->mNode, OMX_CommandPortEnable, kPortIndexOutput),
@@ -6579,7 +7354,7 @@ void ACodec::FlushingState::changeStateIfWeOwnAllBuffers() {
         mCodec->waitUntilAllPossibleNativeWindowBuffersAreReturnedToUs();
 
         sp<AMessage> notify = mCodec->mNotify->dup();
-        notify->setInt32("what", CodecBase::kWhatFlushCompleted);
+        notify->setInt32("what", ACodec::kWhatFlushCompleted);
         notify->post();
 
         mCodec->mPortEOS[kPortIndexInput] =
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 613138886..ac98247a9 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -218,6 +218,39 @@ LOCAL_SHARED_LIBRARIES += \
 endif
 endif
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    ifeq ($(BOARD_MTK_OMX_USES_PRIVATE_YUV),true)
+        LOCAL_CFLAGS += -DMTK_OMX_USES_PRIVATE_YUV
+    endif
+LOCAL_MTK_PATH:=$(TOP)/mediatek/frameworks-ext/av/media/libstagefright
+    LOCAL_C_INCLUDES += \
+        $(TOP)/mediatek/kernel/include \
+        $(TOP)/mediatek/hardware/dpframework/inc \
+        $(TOP)/hardware/mediatek/media/include \
+        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/mediatek/frameworks/av/media/libstagefright/include \
+        $(TOP)/mediatek/frameworks-ext/av/media/libstagefright/include \
+        $(TOP)/frameworks/native/include/media/editor \
+        $(TOP)/external/skia/include/images \
+        $(TOP)/external/skia/include/core \
+        $(TOP)/frameworks/av/libvideoeditor/lvpp
+
+    LOCAL_SHARED_LIBRARIES +=  \
+        libdpframework \
+        libstagefright_memutil \
+        libstagefright_enc_common \
+        libstagefright_avc_common \
+        libstagefright_foundation \
+        libdl \
+        libvcodecdrv \
+        libskia \
+        libcustom_prop
+
+LOCAL_SRC_FILES += \
+        I420ColorConverter.cpp
+
+endif
+
 LOCAL_SHARED_LIBRARIES += \
         libstagefright_enc_common \
         libstagefright_avc_common \
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index f8c326888..b3be4718a 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -42,6 +42,11 @@
 #define UNUSED_UNLESS_VERBOSE(x)
 #endif
 
+#ifdef MTK_HARDWARE
+#include <camera/MtkCamera.h>
+#include <camera/MtkCameraParameters.h>
+#endif
+
 namespace android {
 
 static const int64_t CAMERA_SOURCE_TIMEOUT_NS = 3000000000LL;
@@ -101,10 +106,22 @@ void CameraSourceListener::postDataTimestamp(
 }
 
 static int32_t getColorFormat(const char* colorFormat) {
+#ifdef MTK_HARDWARE
+    ALOGD("getColorFormat(%s)", colorFormat);
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
-       return OMX_COLOR_FormatYUV420Planar;
+        // YV12
+        return OMX_MTK_COLOR_FormatYV12;
     }
 
+    if (!strcmp(colorFormat, "yuv420i-yyuvyy-3plane" /*MtkCameraParameters::PIXEL_FORMAT_YUV420I)*/)) {
+        // i420
+        return OMX_COLOR_FormatYUV420Planar;
+    }
+#else
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
+       return OMX_COLOR_FormatYUV420Planar;
+    }
+#endif
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422SP)) {
        return OMX_COLOR_FormatYUV422SemiPlanar;
     }
@@ -168,11 +185,19 @@ CameraSource *CameraSource::CreateFromCamera(
     Size videoSize,
     int32_t frameRate,
     const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+	 bool storeMetaDataInVideoBuffers,bool supportMCIbuffer) {
+#else
     bool storeMetaDataInVideoBuffers) {
 
+#endif
     CameraSource *source = new CameraSource(camera, proxy, cameraId,
             clientName, clientUid, videoSize, frameRate, surface,
+#ifdef MTK_HARDWARE
+					storeMetaDataInVideoBuffers,supportMCIbuffer);
+#else
             storeMetaDataInVideoBuffers);
+#endif
     return source;
 }
 
@@ -185,7 +210,11 @@ CameraSource::CameraSource(
     Size videoSize,
     int32_t frameRate,
     const sp<IGraphicBufferProducer>& surface,
+#ifdef MTK_HARDWARE
+	bool storeMetaDataInVideoBuffers,bool supportMCIbuffer)
+#else
     bool storeMetaDataInVideoBuffers)
+#endif
     : mCameraFlags(0),
       mNumInputBuffers(0),
       mVideoFrameRate(-1),
@@ -207,6 +236,20 @@ CameraSource::CameraSource(
       mPauseEndTimeUs(0) {
     mVideoSize.width  = -1;
     mVideoSize.height = -1;
+#ifdef MTK_HARDWARE
+	mDropRate = -1;
+	mNumRemainFrameReceived = 1;
+	mLastNumFramesReceived = 1;
+	mCamVideoBufferMode = -1;
+	mCamMemVaArray = NULL;
+	mCamMemIonFdArray = NULL;
+	//for MCI buffer 
+	mSupportMCIbuffer = supportMCIbuffer;
+	mCamRecSetting = NULL;
+	//memset(&mCamRecSetting,0,sizeof(CameraRecSetting));
+	mPaused = false;
+	mResumed = true;
+#endif
 
     mInitCheck = init(camera, proxy, cameraId,
                     clientName, clientUid,
@@ -309,8 +352,13 @@ static void getSupportedVideoSizes(
  */
 status_t CameraSource::isCameraColorFormatSupported(
         const CameraParameters& params) {
+#ifdef MTK_HARDWARE
+// we need to define mtk camera color format
+	mColorFormat = OMX_MTK_COLOR_FormatYV12;
+#else
     mColorFormat = getColorFormat(params.get(
             CameraParameters::KEY_VIDEO_FRAME_FORMAT));
+#endif
     if (mColorFormat == -1) {
         return BAD_VALUE;
     }
@@ -342,10 +390,12 @@ status_t CameraSource::configureCamera(
     getSupportedVideoSizes(*params, &isSetVideoSizeSupportedByCamera, sizes);
     bool isCameraParamChanged = false;
     if (width != -1 && height != -1) {
+#ifndef MTK_HARDWARE
         if (!isVideoSizeSupported(width, height, sizes)) {
             ALOGE("Video dimension (%dx%d) is unsupported", width, height);
             return BAD_VALUE;
         }
+#endif
         if (isSetVideoSizeSupportedByCamera) {
             params->setVideoSize(width, height);
         } else {
@@ -365,6 +415,7 @@ status_t CameraSource::configureCamera(
 
     if (frameRate != -1) {
         CHECK(frameRate > 0 && frameRate <= 120);
+#ifndef MTK_HARDWARE
         const char* supportedFrameRates =
                 params->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES);
         CHECK(supportedFrameRates != NULL);
@@ -377,6 +428,7 @@ status_t CameraSource::configureCamera(
             return BAD_VALUE;
         }
 
+#endif
         // The frame rate is supported, set the camera to the requested value.
         params->setPreviewFrameRate(frameRate);
         isCameraParamChanged = true;
@@ -598,6 +650,95 @@ status_t CameraSource::initWithCameraAccess(
     ExtendedUtils::HFR::setHFRIfEnabled(params, mMeta);
     ExtendedUtils::applyPreRotation(params, mMeta);
 
+#ifdef MTK_HARDWARE
+	//get color effect and transfer to codec
+	//then codec can adjust initial Qp for special color effect such as whiteboard/blackboard
+	const char* colorEffect = newCameraParams.get(CameraParameters::KEY_EFFECT);
+	mMeta->setCString(kKeyColorEffect,colorEffect);
+	ALOGD("color effect:%s",colorEffect);
+
+	if (!mCamera->previewEnabled()) {//Camera return valid memory info after startPreview
+		ALOGW("Start preview in CameraSource");
+		mCamera->startPreview();
+	}
+
+	//for MCI buffer
+	mCamRecSetting = malloc(sizeof(CameraRecSetting));
+	CameraRecSetting* _mCamRecSetting = (CameraRecSetting*)mCamRecSetting;
+	_mCamRecSetting->mi4BufSecu = 0;
+	_mCamRecSetting->mi4BufCohe = 0;
+	if(mSupportMCIbuffer){
+		ALOGI("Support MCI buffer");
+		_mCamRecSetting->mi4BufSecu = 1;
+		_mCamRecSetting->mi4BufCohe = 1;		
+	}
+	mMeta->setInt32(kKeyCamMCIMemSecurity,_mCamRecSetting->mi4BufSecu);
+	mMeta->setInt32(kKeyCamMCIMemCoherent,_mCamRecSetting->mi4BufCohe);
+	
+	Vector<CameraRecBufInfo> VecCamBufInfo;
+	err = mCamera->sendCommand(CAMERA_CMD_GET_REC_BUF_INFO,(int32_t)&VecCamBufInfo, (int32_t)_mCamRecSetting);
+	if(err != OK){
+		//Continus memory info for 77
+		CameraMemInfo memInfo;
+		memInfo.u4Type = CameraMemInfo::eTYPE_PMEM;
+		mCamera->sendCommand(CAMERA_CMD_GET_MEM_INFO, (int32_t)&memInfo, sizeof(CameraMemInfo));
+
+		mMeta->setInt32(kKeyCamMemMode,CAMERA_CONTINUOUS_MEM_MODE);
+		mMeta->setInt32(kKeyCamMemVa, (int32_t)memInfo.u4VABase);
+		mMeta->setInt32(kKeyCamMemSize, (int32_t)memInfo.u4MemSize);
+		mMeta->setInt32(kKeyCamMemCount, (int32_t)memInfo.u4MemCount);
+		ALOGD("Camera Memory Info: VA=%d, Size=%d, Count=%d", (int32_t)memInfo.u4VABase, (int32_t)memInfo.u4MemSize, (int32_t)memInfo.u4MemCount);
+	}
+
+	else { //discontinus memory info for 89
+		if(VecCamBufInfo.size() <= 0){
+			ALOGE("get Camera Memory Info wrong!!!");
+			return err;
+		}
+
+		mMeta->setInt32(kKeyCamMemSize, (int32_t)((VecCamBufInfo.top()).u4Size));
+		mMeta->setInt32(kKeyCamMemCount, (int32_t)VecCamBufInfo.size());
+		ALOGD("Camera Memory Info: Size=%d, Count=%d", (VecCamBufInfo.top()).u4Size,VecCamBufInfo.size());
+		
+		mCamVideoBufferMode = (VecCamBufInfo.top()).i4MemId;
+		ALOGI("Camera Memory Info:Buffer mode %d",mCamVideoBufferMode);
+		
+		if(mCamVideoBufferMode > 0){
+			//Camera allocated memory by ION
+			//now will not go to here	
+				mMeta->setInt32(kKeyCamMemMode,CAMERA_DISCONTINUOUS_MEM_ION_MODE);
+			mCamMemIonFdArray = new int32_t[VecCamBufInfo.size()];
+			memset(mCamMemIonFdArray,0,sizeof(VecCamBufInfo.size() * sizeof(int32_t)));
+
+			mCamMemVaArray = new uint32_t[VecCamBufInfo.size()]; 
+			memset(mCamMemVaArray,0,sizeof(VecCamBufInfo.size() * sizeof(uint32_t)));
+			
+			for(uint32_t i = 0; i < VecCamBufInfo.size();i++){
+				//need tranfer fd for codec module
+				mCamMemIonFdArray[i] = VecCamBufInfo[i].i4MemId;
+
+				mCamMemVaArray[i] = VecCamBufInfo[i].u4VirAddr;
+				
+				ALOGI("Camera Memory Info:mCamMemIonFdArray[%d]=0x%x",i,mCamMemIonFdArray[i]);
+				ALOGI("Camera Memory Info:mCamMemVaArray[%d]=0x%x",i,mCamMemVaArray[i]);
+			}
+				
+			mMeta->setPointer(kKeyCamMemIonFdArray, mCamMemIonFdArray);
+			mMeta->setPointer(kKeyCamMemVaArray, mCamMemVaArray);
+		}
+		else{
+				mMeta->setInt32(kKeyCamMemMode,CAMERA_DISCONTINUOUS_MEM_VA_MODE);
+			mCamMemVaArray = new uint32_t[VecCamBufInfo.size()]; 
+			memset(mCamMemVaArray,0,sizeof(VecCamBufInfo.size() * sizeof(uint32_t)));
+			for(uint32_t i = 0; i < VecCamBufInfo.size();i++){
+				mCamMemVaArray[i] = VecCamBufInfo[i].u4VirAddr;
+				ALOGI("Camera Memory Info:mCamMemVaArray[%d]=0x%x",i,mCamMemVaArray[i]);
+			}
+				
+			mMeta->setPointer(kKeyCamMemVaArray, mCamMemVaArray);
+		}
+	}
+#endif
     return OK;
 }
 
@@ -610,6 +751,22 @@ CameraSource::~CameraSource() {
         // Camera's lock is released in this case.
         releaseCamera();
     }
+#ifdef MTK_HARDWARE
+	if(mCamMemVaArray){
+		delete [] mCamMemVaArray;
+		mCamMemVaArray = NULL;
+	}
+	if(mCamMemIonFdArray){
+		delete [] mCamMemIonFdArray;
+		mCamMemIonFdArray = NULL;
+	}
+
+	//for MCI buffer
+	if(mCamRecSetting){
+		free(mCamRecSetting);
+		mCamRecSetting = NULL;
+	}
+#endif
 }
 
 status_t CameraSource::startCameraRecording() {
@@ -634,6 +791,21 @@ status_t CameraSource::startCameraRecording() {
     err = OK;
     if (mCameraFlags & FLAGS_HOT_CAMERA) {
         mCamera->unlock();
+#ifdef MTK_HARDWARE //back compatible with previous app version
+		status_t err = mCameraRecordingProxy->startRecording(new ProxyListener(this));
+		ALOGD("Proxy start recording %d", err);
+		if (err == NO_INIT) {
+			mCameraFlags &= ~FLAGS_HOT_CAMERA;
+			mCamera->lock();
+			mCamera->reconnect();
+			mCameraRecordingProxy.clear();
+		}
+		else {
+			mCamera.clear();
+		}
+    }
+	if ((mCameraFlags & FLAGS_HOT_CAMERA) == 0) {
+#else
         mCamera.clear();
         if ((err = mCameraRecordingProxy->startRecording(
                 new ProxyListener(this))) != OK) {
@@ -641,6 +813,7 @@ status_t CameraSource::startCameraRecording() {
                     strerror(-err), err);
         }
     } else {
+#endif
         mCamera->setListener(new CameraSourceListener(this));
         mCamera->startRecording();
         if (!mCamera->recordingEnabled()) {
diff --git a/media/libstagefright/MediaBuffer.cpp b/media/libstagefright/MediaBuffer.cpp
index 1f80a47de..2d4f23284 100644
--- a/media/libstagefright/MediaBuffer.cpp
+++ b/media/libstagefright/MediaBuffer.cpp
@@ -83,6 +83,20 @@ MediaBuffer::MediaBuffer(const sp<ABuffer> &buffer)
       mMetaData(new MetaData),
       mOriginal(NULL) {
 }
+#ifdef MTK_HARDWARE
+MediaBuffer::MediaBuffer(size_t size, sp<MetaData> metaData)
+	: mObserver(NULL),
+	  mNextBuffer(NULL),
+	  mRefCount(0),
+	  mData(malloc(size)),
+	  mSize(size),
+	  mRangeOffset(0),
+	  mRangeLength(size),
+	  mOwnsData(true),
+	  mMetaData(new MetaData(*(metaData.get()))),
+	  mOriginal(NULL) {
+}
+#endif
 
 void MediaBuffer::release() {
     if (mObserver == NULL) {
@@ -199,4 +213,12 @@ MediaBuffer *MediaBuffer::clone() {
     return buffer;
 }
 
+#ifdef MTK_HARDWARE
+// just do a release on refcount == 0
+void MediaBufferSimpleObserver::signalBufferReturned(MediaBuffer *buffer) {
+    CHECK_EQ(buffer->refcount(), 0);
+    buffer->setObserver(NULL);
+    buffer->release();
+}
+#endif
 }  // namespace android
diff --git a/media/libstagefright/MediaCodec.cpp b/media/libstagefright/MediaCodec.cpp
index cf7aa4373..5a84f07af 100755
--- a/media/libstagefright/MediaCodec.cpp
+++ b/media/libstagefright/MediaCodec.cpp
@@ -193,7 +193,13 @@ status_t MediaCodec::init(const AString &name, bool nameIsType, bool encoder) {
     mCodec = new ACodec;
     bool needDedicatedLooper = false;
     if (nameIsType && !strncasecmp(name.c_str(), "video/", 6)) {
+#ifdef MTK_HARDWARE
+        //needDedicatedLooper = true;
+        // Not to create video CodecLooper for performance 
+        needDedicatedLooper = false;
+#else
         needDedicatedLooper = true;
+#endif
     } else {
         AString tmp = name;
         if (tmp.endsWith(".secure")) {
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index 54ebb6c87..0befff9ec 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -39,6 +39,9 @@ namespace android {
 
 const char *MEDIA_MIMETYPE_IMAGE_JPEG = "image/jpeg";
 
+#ifdef MTK_HARDWARE
+const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8";
+#endif
 const char *MEDIA_MIMETYPE_VIDEO_VP8 = "video/x-vnd.on2.vp8";
 const char *MEDIA_MIMETYPE_VIDEO_VP9 = "video/x-vnd.on2.vp9";
 const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
diff --git a/media/libstagefright/OMXClient.cpp b/media/libstagefright/OMXClient.cpp
index 629bd129c..2edb550cc 100644
--- a/media/libstagefright/OMXClient.cpp
+++ b/media/libstagefright/OMXClient.cpp
@@ -92,6 +92,25 @@ struct MuxOMX : public IOMX {
             node_id node, OMX_U32 port_index, const sp<IMemory> &params,
             buffer_id *buffer, OMX_BOOL crossProcess);
 
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer);
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer);
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap);
+
+    virtual status_t registerBuffer2(
+        node_id node, OMX_U32 port_index,  const sp<IMemoryHeap> &HeapBase);
+
+    virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer);
+#endif
     virtual status_t useGraphicBuffer(
             node_id node, OMX_U32 port_index,
             const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer);
@@ -319,6 +338,34 @@ status_t MuxOMX::useBuffer(
             node, port_index, params, buffer, OMX_FALSE /* crossProcess */);
 }
 
+#ifdef MTK_HARDWARE
+status_t MuxOMX::useBuffer(
+        node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+        buffer_id *buffer) {
+    return getOMX(node)->useBuffer(node, port_index, virAddr, size, buffer);
+}
+
+status_t MuxOMX::useBuffer(
+        node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+        buffer_id *buffer) {
+    return getOMX(node)->useBuffer(node, port_index, virAddr, size, offset, buffer);
+}
+
+status_t MuxOMX::registerBuffer(
+        node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) {
+    return getOMX(node)->registerBuffer(node, port_index, heap);
+}
+
+status_t MuxOMX::registerBuffer2(
+        node_id node, OMX_U32 port_index,  const sp<IMemoryHeap> &HeapBase) {
+    return getOMX(node)->registerBuffer2(node, port_index, HeapBase);
+}
+
+status_t MuxOMX::useIonBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) {
+    return getOMX(node)->useIonBuffer(node, port_index, virAddr, fd, size, buffer);
+}
+#endif
 status_t MuxOMX::useGraphicBuffer(
         node_id node, OMX_U32 port_index,
         const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer) {
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 4a5375515..9d7a3a007 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -124,6 +124,13 @@
 #include "ExynosHWCService.h"
 #endif
 
+#ifdef MTK_HARDWARE
+#define ENABLE_MTK_BUF_ADDR_ALIGNMENT
+#define MTK_BUF_ADDR_ALIGNMENT_VALUE 512
+#include "sf_mem_util.h"
+#include <cutils/properties.h>
+#endif
+
 namespace android {
 
 #ifdef USE_SAMSUNG_COLORFORMAT
@@ -145,6 +152,10 @@ static int calc_plane(int width, int height)
 }
 #endif // USE_SAMSUNG_COLORFORMAT
 
+#ifdef MTK_HARDWARE
+const static int64_t VDeckBufferFilledEventTimeOutNs = 50000000000LL;// video decode need too much time
+const static int64_t kPreRollTimeOutUs = 3000000LL;//pre roll time out
+#endif
 // Treat time out as an error if we have not received any output
 // buffers after 3 seconds.
 const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
@@ -428,6 +439,22 @@ uint32_t OMXCodec::getComponentQuirks(
     if (info->hasQuirk("requires-flush-complete-emulation")) {
         quirks |= kRequiresFlushCompleteEmulation;
     }
+
+#ifdef MTK_HARDWARE
+    if (info->hasQuirk("decoder-lies-about-number-of-channels")) {
+        quirks |= kDecoderLiesAboutNumberOfChannels;
+    }
+    if (info->hasQuirk("supports-multiple-frames-per-input-buffer")) {
+        quirks |= kSupportsMultipleFramesPerInputBuffer;
+    }
+    if (info->hasQuirk("wants-NAL-fragments")) {
+        quirks |= kWantsNALFragments;
+    }
+    if (info->hasQuirk("avoid-memcpy-input-recording-frames")) {
+        quirks |= kAvoidMemcopyInputRecordingFrames;
+    }
+#endif
+
 #endif // DOLBY_END
 
 #ifdef USE_ALP_AUDIO
@@ -499,6 +526,15 @@ sp<MediaSource> OMXCodec::Create(
         flags |= kIgnoreCodecSpecificData;
         flags |= kUseSecureInputBuffers;
     }
+#ifdef MTK_HARDWARE
+    int32_t requiresMaxFBuffers;
+    if (source->getFormat()->findInt32(
+                kKeyRequiresMaxFBuffers,
+                &requiresMaxFBuffers)
+            && requiresMaxFBuffers) {
+        flags |= kUseMaxOutputBuffers;
+    }
+#endif //MTK_HARDWARE
 
     const char *mime;
     bool success = meta->findCString(kKeyMIMEType, &mime);
@@ -599,6 +635,52 @@ sp<MediaSource> OMXCodec::Create(
                     createEncoder, mime, componentName,
                     source, nativeWindow);
 
+#ifdef MTK_HARDWARE  // Camera recording
+            int32_t prCamMode;
+            int32_t prCamMemInfo;   //CamMemInfo_t pointer
+            CamMCIMemInfo_t* camMCIMemInfo = NULL;
+
+            if (meta->findInt32(kKeyCamMemMode, &prCamMode)) {
+                ALOGD ("Camera Recording Mode (%d)", prCamMode);
+            }
+
+            if (meta->findPointer(kKeyCamMCIMemInfo, (void **)&camMCIMemInfo)) {
+                ALOGD ("Camera Recording SetMCIMode (security = %d, coherent = %d)", camMCIMemInfo->u4Security, camMCIMemInfo->u4Coherent);
+                codec->getCameraMeta()->setPointer(kKeyCamMCIMemInfo, camMCIMemInfo);
+            }
+
+            if (prCamMode == CAMERA_DISCONTINUOUS_MEM_ION_MODE) {
+            	if (meta->findInt32(kKeyCamMemInfo, &prCamMemInfo)) {
+                    ALOGD ("Hello camera recording MEM ION MODE!!!");
+                    for(uint32_t u4I = 0; u4I < ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount; u4I++)
+                    {
+                        ALOGD ("VdoBufVA = 0x%08x, IonFd = %d, VdoBufCount = %d, VdoBufSize = %d,\n",
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufVA[u4I],
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->IonFd,
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount,
+                                       ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufSize
+                                       );
+                    }
+                    codec->getCameraMeta()->setInt32(kKeyCamMemMode, prCamMode);
+                    codec->getCameraMeta()->setInt32(kKeyCamMemInfo, prCamMemInfo);
+            	}
+            }
+            else {   // CAMERA_DISCONTINUOUS_MEM_VA_MODE
+            if (meta->findInt32(kKeyCamMemInfo, &prCamMemInfo)) {
+                    ALOGD ("Hello camera recording MEM VA MODE!!!");
+                for(uint32_t u4I = 0; u4I < ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount; u4I++)
+                {
+                    ALOGD ("VdoBufVA = 0x%08x, VdoBufCount = %d, VdoBufSize = %d,\n",
+                        ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufVA[u4I],
+                        ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount,
+                        ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufSize
+                        );
+                }
+                    codec->getCameraMeta()->setInt32(kKeyCamMemMode, prCamMode);
+                codec->getCameraMeta()->setInt32(kKeyCamMemInfo, prCamMemInfo);
+            }
+            }
+#endif
             observer->setCodec(codec);
 
             { //profile configure codec
@@ -756,13 +838,44 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     ALOGV("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
 
+#ifdef MTK_HARDWARE // must be verified!!
+	//qian
+ 	void* pTs=NULL;
+	CHECK(meta!=NULL);
+	if(meta->findPointer(kkeyOmxTimeSource, &pTs)==true)
+	{
+		CHECK(pTs!=NULL);
+		 mOMX->setParameter(
+		 mNode, OMX_IndexVendorMtkOmxVdecTimeSource, pTs, sizeof(void*));
+    }
+#endif
+
     if (!(mFlags & kIgnoreCodecSpecificData)) {
         uint32_t type;
         const void *data;
         size_t size;
-        if (meta->findData(kKeyESDS, &type, &data, &size)) {
+#ifdef MTK_HARDWARE//check VOS first, than esds
+		if (meta->findData(kKeyMPEG4VOS, &type, &data, &size)) { //MPEG4 raw codec info
+            addCodecSpecificData(data, size);
+		}
+		else if (meta->findData(kKeyESDS, &type, &data, &size))
+#else
+        if (meta->findData(kKeyESDS, &type, &data, &size))
+#endif //MTK_HARDWARE
+ {
             ESDS esds((const char *)data, size);
+#ifdef MTK_HARDWARE
+			{
+				status_t err = esds.InitCheck();
+				if (err != OK)
+				{
+					ALOGE("esds.InitCheck() ERROR %d!!!", err);
+					return err;
+				}
+			}
+#else
             CHECK_EQ(esds.InitCheck(), (status_t)OK);
+#endif //MTK_HARDWARE
 
             const void *codec_specific_data;
             size_t codec_specific_data_size;
@@ -795,6 +908,11 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             CODEC_LOGI(
                     "AVC profile = %u (%s), level = %u",
                     profile, AVCProfileToString(profile), level);
+#ifdef MTK_HARDWARE
+        } else if (meta->findData(kKeyCodecConfigInfo, &type, &data, &size)) {
+            ALOGI("OMXCodec::configureCodec--config Codec Info for AAC");
+            addCodecSpecificData(data, size);
+#endif //MTK_HARDWARE
         } else if (meta->findData(kKeyHVCC, &type, &data, &size)) {
             // Parse the HEVCDecoderConfigurationRecord
 
@@ -858,6 +976,45 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             isADTS = false;
         }
 
+#ifdef MTK_HARDWARE
+        if (!strcmp(mComponentName, "OMX.MTK.AUDIO.DECODER.AAC"))
+        {
+            bool bIsAACADIF = false;
+            int32_t nIsAACADIF;
+            if (meta->findInt32(kKeyIsAACADIF, &nIsAACADIF))
+            {
+                if(0 == nIsAACADIF)
+                    bIsAACADIF = false;
+                else
+                    bIsAACADIF = true;
+            }
+            status_t errAAC;
+            if(bIsAACADIF)
+            {
+                OMX_AUDIO_PARAM_AACPROFILETYPE profileAAC;
+                InitOMXParams(&profileAAC);
+                profileAAC.nPortIndex = kPortIndexInput;
+                errAAC = mOMX->getParameter(
+                    mNode, OMX_IndexParamAudioAac, &profileAAC, sizeof(profileAAC));
+                CHECK_EQ((status_t)OK, errAAC);
+                profileAAC.nChannels = numChannels;
+                profileAAC.nSampleRate = sampleRate;
+                profileAAC.eAACStreamFormat = OMX_AUDIO_AACStreamFormatADIF;
+                errAAC = mOMX->setParameter(
+                    mNode, OMX_IndexParamAudioAac, &profileAAC, sizeof(profileAAC));
+            }
+            else
+            {
+                errAAC = setAACFormat(numChannels, sampleRate, bitRate, aacProfile, isADTS);
+            }
+            if (errAAC != OK)
+            {
+                CODEC_LOGE("setAACFormat() failed (errAAC = %d)", errAAC);
+                return errAAC;
+            }
+        }
+        else {
+#endif //#ifdef MTK_HARDWARE
         status_t err = setAACFormat(numChannels, sampleRate, bitRate, aacProfile, isADTS);
         if (err != OK) {
             CODEC_LOGE("setAACFormat() failed (err = %d)", err);
@@ -874,6 +1031,9 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             addCodecSpecificData(data, size);
         }
 #endif
+#ifdef MTK_HARDWARE
+        }
+#endif //#ifdef MTK_HARDWARE
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG, mMIME)) {
         int32_t numChannels, sampleRate;
         if (meta->findInt32(kKeyChannelCount, &numChannels)
@@ -975,7 +1135,26 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     if (meta->findInt32(kKeyMaxInputSize, &maxInputSize)) {
         setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);
     }
+#ifdef MTK_HARDWARE
+    {
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        status_t err = mOMX->getParameter(
+            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        //CHECK_EQ(err, (status_t)OK);
 
+        if (def.eDomain == OMX_PortDomainVideo)
+        {
+            OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
+            if ( video_def->nFrameHeight == 0 || video_def->nFrameWidth == 0)
+            {
+                ALOGE("%s nFrameHeight = %d  nFrameWidth = %d return bad value",__FUNCTION__,video_def->nFrameHeight,video_def->nFrameWidth);
+                return BAD_VALUE;
+            }
+        }
+    }
+#endif
     initOutputFormat(meta);
 
     if ((mFlags & kClientNeedsFramebuffer)
@@ -1134,6 +1313,15 @@ static size_t getFrameSize(
 #ifdef USE_SAMSUNG_COLORFORMAT
         case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
         case OMX_SEC_COLOR_FormatNV12LPhysicalAddress:
+#endif
+#ifdef MTK_HARDWARE
+        /*
+         * FIXME: We use this FrameSize for temp solution
+         * in order to check functionality,
+         * and we need to get FrameSize accurately in the future
+         */
+        case OMX_MTK_COLOR_FormatYV12:
+        case OMX_COLOR_FormatVendorMTKYUV:
 #endif
             return (width * height * 3) / 2;
 #ifdef USE_SAMSUNG_COLORFORMAT
@@ -1367,8 +1555,8 @@ status_t OMXCodec::setupErrorCorrectionParameters() {
     }
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
-    errorCorrectionType.bEnableResync = OMX_FALSE;
-    errorCorrectionType.nResynchMarkerSpacing = 0;
+    errorCorrectionType.bEnableResync = OMX_TRUE;
+    errorCorrectionType.nResynchMarkerSpacing = 256;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
@@ -1837,6 +2025,9 @@ OMXCodec::OMXCodec(
       mSeekMode(ReadOptions::SEEK_CLOSEST_SYNC),
       mTargetTimeUs(-1),
       mOutputPortSettingsChangedPending(false),
+#ifdef MTK_HARDWARE
+      mIsHttpStreaming(false),
+#endif
       mSkipCutBuffer(NULL),
       mLeftOverBuffer(NULL),
       mPaused(false),
@@ -1844,6 +2035,23 @@ OMXCodec::OMXCodec(
       mDolbyProcessedAudio(false),
       mDolbyProcessedAudioStateChanged(false),
 #endif // DOLBY_END
+#ifdef MTK_HARDWARE
+      mIsVideoDecoder (false),
+      mIsVideoEncoder(false),
+      mInputBufferPoolMemBase(NULL),
+      mOutputBufferPoolMemBase(NULL),
+      mMemHeapBase(NULL),
+      mPropFlags(0),
+      mMaxQueueBufferNum(0),
+      mQueueWaiting(false),
+      mSupportsPartialFrames(false),
+      mVideoAspectRatioWidth(1),
+      mVideoAspectRatioHeight(1),
+      mIsVENCTimelapseMode(false),
+      mPreRollStartTime(-1),
+      mRTSPOutputTimeoutUS(-1),
+      mHTTPOutputTimeoutUS(-1),
+#endif
       mNativeWindow(
               (!strncmp(componentName, "OMX.google.", 11)
               || !strncmp(componentName, "OMX.ffmpeg.", 11))
@@ -1855,6 +2063,44 @@ OMXCodec::OMXCodec(
     mPortStatus[kPortIndexOutput] = ENABLING;
 
     setComponentRole();
+
+#ifdef MTK_HARDWARE
+    if (false == mIsEncoder) {
+        if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VPX, mime))) {
+            mIsVideoDecoder = true;
+
+            char value[PROPERTY_VALUE_MAX];
+            property_get("omxcodec.video.input.error.rate", value, "0.0");
+            mVideoInputErrorRate = atof(value);
+            if (mVideoInputErrorRate > 0) {
+                mPropFlags |= OMXCODEC_ENABLE_VIDEO_INPUT_ERROR_PATTERNS;
+            }
+            ALOGD ("mVideoInputErrorRate(%f)", mVideoInputErrorRate);
+        }
+    }
+    else {
+        if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) ||
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime))) {
+            mIsVideoEncoder = true;
+
+#ifdef MTK_HARDWARE  // for Camera recording
+            mCameraMeta = new MetaData;
+
+            if (!mOMXLivesLocally) {
+                mQuirks &= ~kAvoidMemcopyInputRecordingFrames;
+            }
+#endif
+        }
+    }
+
+    ALOGD ("!@@!>> create tid (%d) OMXCodec mOMXLivesLocally=%d, mIsVideoDecoder(%d), mIsVideoEncoder(%d), mime(%s)", gettid(), mOMXLivesLocally, mIsVideoDecoder, mIsVideoEncoder, mime);
+#endif
+
 }
 
 // static
@@ -1908,6 +2154,10 @@ void OMXCodec::setComponentRole(
             "video_decoder.mpeg4", NULL },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
+#ifdef MTK_HARDWARE
+        { MEDIA_MIMETYPE_VIDEO_VPX,
+            "video_decoder.vpx", "video_encoder.vpx" },
+#endif //MTK_HARDWARE
         { MEDIA_MIMETYPE_VIDEO_VP8,
             "video_decoder.vp8", "video_encoder.vp8" },
         { MEDIA_MIMETYPE_VIDEO_VP9,
@@ -1983,6 +2233,9 @@ void OMXCodec::setComponentRole() {
 }
 
 OMXCodec::~OMXCodec() {
+#ifdef MTK_HARDWARE
+    CHECK_EQ(mQueueWaiting, false);
+#endif
     mSource.clear();
 
     CHECK(mState == LOADED || mState == ERROR || mState == LOADED_TO_IDLE);
@@ -2000,6 +2253,30 @@ OMXCodec::~OMXCodec() {
 
     free(mMIME);
     mMIME = NULL;
+
+#ifdef MTK_HARDWARE
+
+    if (mMemHeapBase != NULL)
+    {
+        if (mInputBufferPoolMemBase) {
+            if (mOMXLivesLocally) {
+                sf_memheap_remove_info (mInputBufferPoolMemBase);
+            }
+            mInputBufferPoolMemBase = NULL;
+        }
+
+        if (mOutputBufferPoolMemBase) {
+            if (mOMXLivesLocally) {
+                sf_memheap_remove_info (mOutputBufferPoolMemBase);
+            }
+            mOutputBufferPoolMemBase = NULL;
+        }
+        mMemHeapBase = NULL;
+    }
+
+    ALOGD ("!@@!>> destroy tid (%d) OMXCodec mOMXLivesLocally=%d, mIsVideoDecoder(%d), mIsVideoEncoder(%d)", gettid(), mOMXLivesLocally, mIsVideoDecoder, mIsVideoEncoder);
+#endif
+
 }
 
 status_t OMXCodec::init() {
@@ -2007,6 +2284,44 @@ status_t OMXCodec::init() {
 
     CHECK_EQ((int)mState, (int)LOADED);
 
+#ifdef MTK_HARDWARE
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    const char *mime = NULL;
+    int32_t width,height;
+    sp<MetaData> meta = mSource->getFormat();
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VPX, mime)) { // Morris Yang add for VP8
+        meta->findInt32(kKeyWidth, &width);
+        meta->findInt32(kKeyHeight, &height);
+
+        ALOGD ("Set VP8 bitstream size. width=%d, height=%d", width, height);
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexInput;
+        status_t err1 = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ((int)err1, (int)OK);
+
+        if ((width > 720) || (height > 720)) {
+            def.nBufferCountActual = 6;
+            def.nBufferSize = 1024*1024;
+        } else {
+            def.nBufferCountActual = 6;
+            def.nBufferSize=width*height*3>>1;
+        }
+
+        err1 = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ((int)err1, (int)OK);
+        }
+
+        if (mIsVideoEncoder && (mCameraMeta.get() != NULL) && (mFlags & kOnlySubmitOneInputBufferAtOneTime) &&
+            (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mMIME) || !strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mMIME) || !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME))) {
+            // Timelapse mode
+            ALOGD ("Set timelapse mode");
+            OMX_BOOL bTimeLapseEnabled = OMX_TRUE;
+            status_t err2 = mOMX->setParameter(mNode, OMX_IndexVendorMtkOmxVencSetTimelapseMode, &bTimeLapseEnabled, sizeof(bTimeLapseEnabled));
+            CHECK_EQ((int)err2, (int)OK);
+            mIsVENCTimelapseMode = true;
+        }
+#endif //MTK_HARDWARE
     status_t err;
     if (!(mQuirks & kRequiresLoadedToIdleAfterAllocation)) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
@@ -2054,34 +2369,210 @@ status_t OMXCodec::allocateBuffers() {
     return allocateBuffersOnPort(kPortIndexOutput);
 }
 
+#ifdef MTK_HARDWARE
 status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
-    const char* type = portIndex == kPortIndexInput ?
-                                    STATS_PROFILE_ALLOCATE_INPUT(mIsVideo) :
-                                    STATS_PROFILE_ALLOCATE_OUTPUT(mIsVideo);
-    ExtendedStats::AutoProfile autoProfile(type, mPlayerExtendedStats);
+    switch (portIndex)
+    {
+        case kPortIndexInput:
+            return allocateBuffersOnInputPort();
+        case kPortIndexOutput:
+            return allocateBuffersOnOutputPort();
 
-    if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        return allocateOutputBuffersFromNativeWindow();
+        default:
+            ALOGE ("[ERROR] OMXCodec::allocateBuffersOnPort  invalid port index");
+            break;
     }
 
-    if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
-        ALOGE("protected output buffers must be stent to an ANativeWindow");
-        return PERMISSION_DENIED;
-    }
+    return OK;
+}
+
 
+status_t OMXCodec::allocateBuffersOnInputPort() {
     status_t err = OK;
-    if ((mFlags & kStoreMetaDataInVideoBuffers)
-            && portIndex == kPortIndexInput) {
+    if (mFlags & kStoreMetaDataInVideoBuffers) {
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
         if (err != OK) {
             ALOGE("Storing meta data in video buffers is not supported");
             return err;
         }
+
+// for live effect recording
+        ALOGD ("@@ allocateBuffersOnInputPort (kStoreMetaDataInVideoBuffers)");
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexInput;
+        status_t err;
+
+        err = mOMX->getParameter(
+                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        if (err != OK) {
+            return err;
+        }
+
+        def.nBufferCountActual = 5;
+        def.nBufferSize = 4 + sizeof (buffer_handle_t);
+        ALOGD ("@@ def.nBufferSize(%d)", def.nBufferSize);
+        err = mOMX->setParameter(
+                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+        if (err != OK) {
+            return err;
+        }
+
+        for (OMX_U32 i = 0 ; i < def.nBufferCountActual ; ++i) {
+            BufferInfo info;
+            info.mData = NULL;
+            info.mSize = def.nBufferSize;
+            info.mData = NULL;
+            IOMX::buffer_id buffer;
+            err = mOMX->useBuffer(mNode, kPortIndexInput, (unsigned char*)info.mData, def.nBufferSize, &buffer);
+
+            info.mBuffer = buffer;
+            info.mStatus = OWNED_BY_US;
+            info.mMediaBuffer = NULL;
+
+            mPortBuffers[kPortIndexInput].push(info);
+        }
+
+        return OK;
+// ]
+    }
+
+// for Camera recording
+    bool bIsCameraRecording = false;
+    int32_t prCamMode;
+    int32_t prCamMemInfo;   //CamMemInfo_t pointer
+    if ((mCameraMeta.get() != NULL) &&mCameraMeta->findInt32(kKeyCamMemInfo, &prCamMemInfo) && mCameraMeta->findInt32(kKeyCamMemMode, &prCamMode)) {
+        ALOGD ("allocateBuffersOnInputPort Camera Recording Mode (%d)", prCamMode);
+        bIsCameraRecording = true;
+        // Morris Yang 20121203
+        if (prCamMode == CAMERA_DISCONTINUOUS_MEM_ION_MODE) {
+            for(uint32_t u4I = 0; u4I < ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount; u4I++)
+            {
+                ALOGD ("VdoBufVA = 0x%08x, IonFd = %d, VdoBufCount = %d, VdoBufSize = %d,\n",
+                               ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufVA[u4I],
+                               ((CamMemIonInfo_t*)prCamMemInfo)->IonFd[u4I],
+                               ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount,
+                               ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufSize
+                                 );
+            }
+        }
+        else {   // CAMERA_DISCONTINUOUS_MEM_VA_MODE
+            for(uint32_t u4I = 0; u4I < ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount; u4I++)
+            {
+                ALOGD ("@@ VdoBufVA = 0x%08x, VdoBufCount = %d, VdoBufSize = %d,\n",
+                    ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufVA[u4I],
+                    ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount,
+                    ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufSize
+                );
+            }
+        }
+    }
+
+    CamMCIMemInfo_t* camMCIMemInfo = NULL;
+    if (bIsCameraRecording && mCameraMeta->findPointer(kKeyCamMCIMemInfo, (void **)&camMCIMemInfo)) {
+        ALOGD("MCI u4Security %d, u4Coherent %d\n", camMCIMemInfo->u4Security, camMCIMemInfo->u4Coherent);
+        if ((camMCIMemInfo->u4Security > 0) && (camMCIMemInfo->u4Coherent > 0)) {
+            ALOGD ("Set MCI mode");
+            OMX_BOOL bEnableMCI = OMX_TRUE;
+            status_t err2 = mOMX->setParameter(mNode, OMX_IndexVendorMtkOmxVencSetMCIMode, &bEnableMCI, sizeof(bEnableMCI));
+            CHECK_EQ((int)err2, (int)OK);
+        }
+    }
+
+    if (bIsCameraRecording) {
+    	// Morris Yang 20121203
+    	if (prCamMode == CAMERA_DISCONTINUOUS_MEM_ION_MODE) {
+            OMX_PARAM_PORTDEFINITIONTYPE def;
+            InitOMXParams(&def);
+            def.nPortIndex = kPortIndexInput;
+            status_t err;
+
+            err = mOMX->getParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            if (err != OK) {
+                return err;
+            }
+
+            def.nBufferCountActual = ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufCount;
+            def.nBufferSize = ((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufSize;
+            err = mOMX->setParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+            if (err != OK) {
+                return err;
+            }
+
+            CODEC_LOGI ("@@ def.nBufferCountActual = %d,\n", def.nBufferCountActual);
+
+            for (OMX_U32 i = 0 ; i < def.nBufferCountActual ; ++i) {
+                BufferInfo info;
+                info.mData = NULL;
+                info.mSize = def.nBufferSize;
+
+                info.mData = (void*)(((CamMemIonInfo_t*)prCamMemInfo)->u4VdoBufVA[i]);
+                OMX_S32 fd = (OMX_S32)(((CamMemIonInfo_t*)prCamMemInfo)->IonFd[i]);
+
+                IOMX::buffer_id buffer;
+                err = mOMX->useIonBuffer(mNode, kPortIndexInput, (unsigned char*)info.mData, fd, def.nBufferSize, &buffer);
+
+                info.mBuffer = buffer;
+                info.mStatus = OWNED_BY_US;
+                info.mMediaBuffer = NULL;
+
+                mPortBuffers[kPortIndexInput].push(info);
+            }
+
+            return OK;
+    	}
+    	else  { // CAMERA_DISCONTINUOUS_MEM_VA_MODE
+            OMX_PARAM_PORTDEFINITIONTYPE def;
+            InitOMXParams(&def);
+            def.nPortIndex = kPortIndexInput;
+            status_t err;
+
+            err = mOMX->getParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            if (err != OK) {
+                return err;
+            }
+
+            def.nBufferCountActual = ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufCount;
+            def.nBufferSize = ((CamMemInfo_t*)prCamMemInfo)->u4VdoBufSize;
+            err = mOMX->setParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+            if (err != OK) {
+                return err;
+            }
+
+            CODEC_LOGI ("@@ def.nBufferCountActual = %d,\n", def.nBufferCountActual);
+
+            for (OMX_U32 i = 0 ; i < def.nBufferCountActual ; ++i) {
+                BufferInfo info;
+                info.mData = NULL;
+                info.mSize = def.nBufferSize;
+
+                info.mData = (void*)(((CamMemInfo_t*)prCamMemInfo)->u4VdoBufVA[i]);
+
+                IOMX::buffer_id buffer;
+
+                err = mOMX->useBuffer(mNode, kPortIndexInput, (unsigned char*)info.mData, def.nBufferSize, &buffer);
+
+                info.mBuffer = buffer;
+                info.mStatus = OWNED_BY_US;
+                info.mMediaBuffer = NULL;
+
+                mPortBuffers[kPortIndexInput].push(info);
+            }
+
+            return OK;
+    	}
     }
 
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
-    def.nPortIndex = portIndex;
+    def.nPortIndex = kPortIndexInput;
 
     err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
@@ -2090,60 +2581,503 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         return err;
     }
 
-    CODEC_LOGI("allocating %lu buffers of size %lu on %s port",
-            def.nBufferCountActual, def.nBufferSize,
-            portIndex == kPortIndexInput ? "input" : "output");
+// alignment patch [
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    def.nBufferSize = ((def.nBufferSize + MTK_BUF_ADDR_ALIGNMENT_VALUE-1) & ~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+  #else
+    def.nBufferSize = ((def.nBufferSize + 32-1) & ~(32-1));
+  #endif
+    ALOGD ("@@ [IN] def.nBufferSize = %d", def.nBufferSize);
+// ]
+
+    ALOGD ("allocating %lu buffers of size %lu on input port", def.nBufferCountActual, def.nBufferSize);
+
+// Morris Yang alignment patch [
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    size_t totalSize = def.nBufferCountActual * (((def.nBufferSize + MTK_BUF_ADDR_ALIGNMENT_VALUE-1) & ~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1)) + MTK_BUF_ADDR_ALIGNMENT_VALUE);
+  #else
+    size_t totalSize = def.nBufferCountActual * ((def.nBufferSize + 32-1) & ~(32-1));
+  #endif
+    ALOGD ("@@ Input totalSize = %d", totalSize);
+// ]
+
+    if (mIsVideoEncoder) {
+        if (mOMXLivesLocally) {
+            mMemHeapBase = new MemoryHeapBase(totalSize, 0, "M4UMemPool");
+            if (mMemHeapBase == NULL) {
+                ALOGE ("[ERROR][M4U] M4UMemPool error: could not create master heap!");
+                return UNKNOWN_ERROR;
+            }
+            mInputBufferPoolMemBase = (unsigned char*) mMemHeapBase->getBase();
+            ALOGD ("mMemHeapBase, = 0x%x, mInputBufferPoolPmemBase = 0x%08X\n", mMemHeapBase.get(), (unsigned int)mInputBufferPoolMemBase);
+            MemHeapInfo memheapinfo;
+            memheapinfo.base = mInputBufferPoolMemBase;
+            memheapinfo.mMemHeapBase = (int)(&mMemHeapBase);
+            memheapinfo.size = totalSize;
+            ALOGD ("before: base = 0x%x, mMemHeapBase = 0x%08X, size = %d", (unsigned int)memheapinfo.base, (unsigned int)memheapinfo.mMemHeapBase, (unsigned int)memheapinfo.size);
+            sf_memheap_set_info(&memheapinfo);
+
+            MemHeapInfo memheapinfo_2;
+            sf_memheap_get_info(mInputBufferPoolMemBase, &memheapinfo_2);
+            ALOGD("after: base = 0x%x, mMemHeapBase = 0x%08X, size = %d", (unsigned int)memheapinfo_2.base, (unsigned int)memheapinfo_2.mMemHeapBase, (unsigned int)memheapinfo_2.size);
+        }
+        else {
+            mMemHeapBase = new MemoryHeapBase(totalSize, 0, "M4UMemPool");
+            if (mMemHeapBase == NULL) {
+                ALOGE ("[ERROR][M4U] M4UMemPool error: could not create master heap!");
+                return UNKNOWN_ERROR;
+            }
+            mInputBufferPoolMemBase = (unsigned char*) mMemHeapBase->getBase();
+            ALOGD ("mMemHeapBase = 0x%08X, mInputBufferPoolPmemBase = 0x%08X, size=%d", mMemHeapBase.get(), (unsigned int)mInputBufferPoolMemBase, mMemHeapBase->getSize());
 
-    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
-        return BAD_VALUE;
+            if (mMemHeapBase->getHeapID() < 0) {
+                ALOGE("Error creating frame buffer heap");
+                return UNKNOWN_ERROR;
+            }
+            err = mOMX->registerBuffer2(mNode, kPortIndexInput, mMemHeapBase);
+        }
     }
-#ifdef MTK_HARDWARE
-    OMX_U32 memoryAlign = 32;
-    size_t totalSize = def.nBufferCountActual *
-        ((def.nBufferSize + (memoryAlign - 1))&(~(memoryAlign - 1)));
-#else
-    size_t totalSize = def.nBufferCountActual * def.nBufferSize;
-#endif
-    mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
-
-    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
-        sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
-        if (mem == NULL || mem->pointer() == NULL) {
-            return NO_MEMORY;
+    else {
+        mDealer[kPortIndexInput] = new MemoryDealer(totalSize, "OMXCodec");
+        sp<IMemoryHeap> pheap = mDealer[kPortIndexInput]->getMemoryHeap();
+        if (pheap->getHeapID() < 0)
+        {
+            ALOGE ("Error creating input buffer heap fail.");
+            return UNKNOWN_ERROR;
         }
+    }
 
+    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
+        sp<IMemory> mem;
         BufferInfo info;
         info.mData = NULL;
         info.mSize = def.nBufferSize;
 
-        IOMX::buffer_id buffer;
-        if (portIndex == kPortIndexInput
-                && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
-                    || (mFlags & kUseSecureInputBuffers))) {
-            if (mOMXLivesLocally) {
-                mem.clear();
+        if (!mIsVideoEncoder) {
+            mem = mDealer[kPortIndexInput]->allocate(def.nBufferSize);
+            CHECK(mem.get() != NULL);
+        } else {
+            info.mData = mInputBufferPoolMemBase + (i * def.nBufferSize);
+            //LOGE ("info.mData(%d) allocated from pmem (0x%x) for input port", i, info.mData);
+        }
 
-                err = mOMX->allocateBuffer(
-                        mNode, portIndex, def.nBufferSize, &buffer,
-                        &info.mData);
-            } else {
-                err = mOMX->allocateBufferWithBackup(
-                        mNode, portIndex, mem, &buffer);
-            }
-        } else if (portIndex == kPortIndexOutput
-                && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
+        IOMX::buffer_id buffer;
+        if ((mQuirks & kRequiresAllocateBufferOnInputPorts) || (mFlags & kUseSecureInputBuffers)) {
             if (mOMXLivesLocally) {
                 mem.clear();
 
                 err = mOMX->allocateBuffer(
-                        mNode, portIndex, def.nBufferSize, &buffer,
+                        mNode, kPortIndexInput, def.nBufferSize, &buffer,
                         &info.mData);
             } else {
                 err = mOMX->allocateBufferWithBackup(
-                        mNode, portIndex, mem, &buffer);
+                        mNode, kPortIndexInput, mem, &buffer);
             }
-        } else {
-            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer);
+        }
+        else {
+            if (mIsVideoEncoder && mOMXLivesLocally) {
+                err = mOMX->useBuffer(mNode, kPortIndexInput, (unsigned char*)info.mData, def.nBufferSize, &buffer);
+            }
+            else if (mIsVideoEncoder && !mOMXLivesLocally) {
+                err = mOMX->useBuffer(mNode, kPortIndexInput, NULL, def.nBufferSize, (i * def.nBufferSize), &buffer);
+            }
+            else {
+            err = mOMX->useBuffer(mNode, kPortIndexInput, mem, &buffer);
+        }
+        }
+
+        if (err != OK) {
+            ALOGE("allocate_buffer_with_backup failed");
+            return err;
+        }
+
+        if (mem != NULL) {
+// Morris Yang alignment patch [
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    OMX_U8 *ptr = static_cast<OMX_U8 *>(mem->pointer());
+    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr)+(MTK_BUF_ADDR_ALIGNMENT_VALUE-1))&~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+    info.mData = (void*)pBuffer;
+  #else
+    info.mData = mem->pointer();
+  #endif
+    ALOGD ("@@ Input[%d], info.mData(0x%08X)", i, info.mData);
+// ]
+        }
+
+        info.mBuffer = buffer;
+        info.mStatus = OWNED_BY_US;
+        info.mMem = mem;
+        info.mMediaBuffer = NULL;
+
+        mPortBuffers[kPortIndexInput].push(info);
+
+        CODEC_LOGV("allocated buffer %p on input port", buffer);
+    }
+
+    // dumpPortStatus(portIndex);
+
+    if (mFlags & kUseSecureInputBuffers) {
+        Vector<MediaBuffer *> buffers;
+        for (size_t i = 0; i < def.nBufferCountActual; ++i) {
+            const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);
+
+            MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);
+            buffers.push(mbuf);
+        }
+
+        status_t err = mSource->setBuffers(buffers);
+
+        if (err != OK) {
+            for (size_t i = 0; i < def.nBufferCountActual; ++i) {
+                buffers.editItemAt(i)->release();
+            }
+            buffers.clear();
+
+            CODEC_LOGE(
+                    "Codec requested to use secure input buffers but "
+                    "upstream source didn't support that.");
+
+            return err;
+        }
+    }
+
+    return OK;
+}
+
+status_t OMXCodec::allocateBuffersOnOutputPort() {
+    if (mNativeWindow != NULL) {
+        return allocateOutputBuffersFromNativeWindow();
+    }
+
+    if (mFlags & kEnableGrallocUsageProtected) {
+        ALOGE("protected output buffers must be stent to an ANativeWindow");
+        return PERMISSION_DENIED;
+    }
+// Morris Yang for Camera recording
+    bool bIsCameraRecording = false;
+    int32_t prCamMemInfo;   //CamMemInfo_t pointer
+    if ((mCameraMeta.get() != NULL) && mCameraMeta->findInt32(kKeyCamMemInfo, &prCamMemInfo)) {
+        ALOGD ("@@ allocateBuffersOnOutputPort (CAMERA RECORDING)");
+        bIsCameraRecording = true;
+    }
+
+    if (bIsCameraRecording) {
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        status_t err = mOMX->getParameter(
+                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        if (err != OK) {
+            return err;
+        }
+
+        def.nBufferSize = ((def.nBufferSize + 32-1) & ~(32-1));
+        ALOGD ("@@ def.nBufferSize(aligned)=%d", def.nBufferSize);
+
+        size_t totalSize = def.nBufferCountActual * def.nBufferSize;
+
+        if (mOutputBufferPoolMemBase)    // free the memory allocated before (In case of port re-config)
+        {
+            mMemHeapBase = NULL;
+            mOutputBufferPoolMemBase = NULL;
+        }
+        mMemHeapBase = new MemoryHeapBase(totalSize, 0, "M4UMemPool");
+        if (mMemHeapBase == NULL) {
+            ALOGE("[ERROR][M4U] M4UMemPool error: could not create master heap!");
+            return UNKNOWN_ERROR;
+        }
+        mOutputBufferPoolMemBase = (unsigned char*) mMemHeapBase->getBase();
+        ALOGD("mMemHeapBase = 0x%08X, mOutputBufferPoolMemBase = 0x%08X, size = %d", mMemHeapBase.get(), (unsigned int)mOutputBufferPoolMemBase, mMemHeapBase->getSize());
+
+        if (mMemHeapBase->getHeapID() < 0) {
+            ALOGE("Error creating frame buffer heap (M4U)");
+            return UNKNOWN_ERROR;
+        }
+        for (OMX_U32 i = 0 ; i < def.nBufferCountActual ; ++i) {
+            BufferInfo info;
+            info.mData = NULL;
+            info.mSize = def.nBufferSize;
+
+            info.mData = mOutputBufferPoolMemBase + (i * def.nBufferSize);
+
+            IOMX::buffer_id buffer;
+            err = mOMX->useBuffer(mNode, kPortIndexOutput, (unsigned char*)info.mData, def.nBufferSize, &buffer);
+
+            info.mBuffer = buffer;
+            info.mStatus = OWNED_BY_US;
+            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
+            info.mMediaBuffer->setObserver(this);
+
+            mPortBuffers[kPortIndexOutput].push(info);
+        }
+
+        return OK;
+    }
+
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+
+    status_t err = mOMX->getParameter(
+        mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+    if (err != OK) {
+        return err;
+    }
+
+// Morris Yang alignment patch [
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    def.nBufferSize = ((def.nBufferSize + MTK_BUF_ADDR_ALIGNMENT_VALUE-1) & ~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+  #else
+    def.nBufferSize = ((def.nBufferSize + 32-1) & ~(32-1));
+  #endif
+    ALOGE ("@@ [OUT] def.nBufferSize = %d", def.nBufferSize);
+// ]
+
+// Morris Yang alignment patch [
+
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    size_t totalSize = def.nBufferCountActual * def.nBufferSize + MTK_BUF_ADDR_ALIGNMENT_VALUE;
+  #else
+    size_t totalSize = def.nBufferCountActual * def.nBufferSize;
+  #endif
+        ALOGE ("@@ [OUT] totalSize = %d", totalSize);
+// ]
+
+    if (mIsVideoDecoder) {
+
+        if (mOutputBufferPoolMemBase)    // free the memory allocated before (In case of port re-config)
+        {
+            mMemHeapBase = NULL;
+            sf_memheap_remove_info (mOutputBufferPoolMemBase);
+            mOutputBufferPoolMemBase = NULL;
+        }
+        mMemHeapBase = new MemoryHeapBase(totalSize, 0, "M4UMemPool");
+        if (mMemHeapBase == NULL) {
+            ALOGE("[ERROR][M4U] M4UMemPool error: could not create master heap!");
+            return UNKNOWN_ERROR;
+        }
+        mOutputBufferPoolMemBase = (unsigned char*) mMemHeapBase->getBase();
+        ALOGD("mMemHeapBase = 0x%08X, mOutputBufferPoolMemBase = 0x%08X, size = %d", mMemHeapBase.get(), (unsigned int)mOutputBufferPoolMemBase, mMemHeapBase->getSize());
+
+        if (mMemHeapBase->getHeapID() < 0) {
+            CODEC_LOGE("Error creating frame buffer heap (M4U)");
+            return UNKNOWN_ERROR;
+        }
+
+        if(mOMXLivesLocally) {
+            MemHeapInfo memheapinfo;
+            memheapinfo.base = mOutputBufferPoolMemBase;
+            memheapinfo.mMemHeapBase = (int)(&mMemHeapBase);
+            memheapinfo.size = totalSize;
+            ALOGD("before: base = 0x%x, mMemHeapBase = 0x%08X, size = %d", (unsigned int)memheapinfo.base, (unsigned int)memheapinfo.mMemHeapBase, (unsigned int)memheapinfo.size);
+            sf_memheap_set_info(&memheapinfo);
+
+            MemHeapInfo memheapinfo_2;
+            sf_memheap_get_info(mOutputBufferPoolMemBase, &memheapinfo_2);
+            ALOGD("after: base = 0x%x, mMemHeapBase = 0x%08X, size = %d", (unsigned int)memheapinfo_2.base, (unsigned int)memheapinfo_2.mMemHeapBase, (unsigned int)memheapinfo_2.size);
+        }
+        else {
+            err = mOMX->registerBuffer2(mNode, kPortIndexOutput, mMemHeapBase);
+        }
+    }
+    else {
+        mDealer[kPortIndexOutput] = new MemoryDealer(totalSize, "OMXCodec");
+        sp<IMemoryHeap> pheap = mDealer[kPortIndexOutput]->getMemoryHeap();
+        if (pheap->getHeapID() < 0)
+        {
+            ALOGE("Error creating output buffer heap fail.");
+            return UNKNOWN_ERROR;
+        }
+        ALOGD ("OMXCodec::allocateBuffersOnOutputPort:totalSize=%d",totalSize);
+    }
+
+    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
+        sp<IMemory> mem;
+        BufferInfo info;
+        info.mData = NULL;
+        info.mSize = def.nBufferSize;
+        if (!mIsVideoDecoder) {
+            mem = mDealer[kPortIndexOutput]->allocate(def.nBufferSize);
+            CHECK(mem.get() != NULL);
+        } else {
+            info.mData = mOutputBufferPoolMemBase + (i * def.nBufferSize);
+            //CODEC_LOGD ("info.mData(%d) allocated from pmem (0x%x) for output port", i, info.mData);
+        }
+
+        IOMX::buffer_id buffer;
+        if (mQuirks & kRequiresAllocateBufferOnOutputPorts) {
+            if (mOMXLivesLocally) {
+                mem.clear();
+
+                err = mOMX->allocateBuffer(
+                        mNode, kPortIndexOutput, def.nBufferSize, &buffer,
+                        &info.mData);
+            } else {
+                err = mOMX->allocateBufferWithBackup(
+                        mNode, kPortIndexOutput, mem, &buffer);
+            }
+        }
+        else {
+            if (mIsVideoDecoder && mOMXLivesLocally) {
+                err = mOMX->useBuffer(mNode, kPortIndexOutput, (unsigned char*)info.mData, def.nBufferSize, &buffer);
+            }
+            else if (mIsVideoDecoder && !mOMXLivesLocally) {
+                err = mOMX->useBuffer(mNode, kPortIndexOutput, NULL, def.nBufferSize, (i * def.nBufferSize), &buffer);
+            }
+            else{
+                err = mOMX->useBuffer(mNode, kPortIndexOutput, mem, &buffer);
+            }
+        }
+
+        if (err != OK) {
+            ALOGE("allocate_buffer_with_backup failed");
+            return err;
+        }
+
+        if ((mem != NULL) && !mIsVideoDecoder) {
+// Morris Yang alignment patch [
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    OMX_U8 *ptr = static_cast<OMX_U8 *>(mem->pointer());
+    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr)+(MTK_BUF_ADDR_ALIGNMENT_VALUE-1))&~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+    info.mData = (void*)pBuffer;
+  #else
+    info.mData = mem->pointer();
+    #endif
+// ]
+        }
+
+        info.mBuffer = buffer;
+        info.mStatus = OWNED_BY_US;
+        info.mMem = mem;
+        info.mMediaBuffer = NULL;
+
+        if (!(mOMXLivesLocally
+          && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
+          && (mQuirks & kDefersOutputBufferAllocation))) {
+            // If the node does not fill in the buffer ptr at this time,
+            // we will defer creating the MediaBuffer until receiving
+            // the first FILL_BUFFER_DONE notification instead.
+            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);
+            info.mMediaBuffer->setObserver(this);
+        }
+
+        mPortBuffers[kPortIndexOutput].push(info);
+
+        ALOGV("allocated buffer %p on output port", buffer);
+    }
+
+    sp<MetaData> meta = mSource->getFormat();
+    int32_t delay = 0;
+    if (!meta->findInt32(kKeyEncoderDelay, &delay)) {
+        delay = 0;
+    }
+    int32_t padding = 0;
+    if (!meta->findInt32(kKeyEncoderPadding, &padding)) {
+        padding = 0;
+    }
+    int32_t numchannels = 0;
+    if (delay + padding) {
+        if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {
+            size_t frameSize = numchannels * sizeof(int16_t);
+            if (mSkipCutBuffer != NULL) {
+                size_t prevbuffersize = mSkipCutBuffer->size();
+                if (prevbuffersize != 0) {
+                    ALOGW("Replacing SkipCutBuffer holding %d bytes", prevbuffersize);
+                }
+            }
+            mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);
+        }
+    }
+
+    //dumpPortStatus(portIndex);
+    return OK;
+}
+#else //ifndef MTK_HARDWARE
+status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
+    const char* type = portIndex == kPortIndexInput ?
+                                    STATS_PROFILE_ALLOCATE_INPUT(mIsVideo) :
+                                    STATS_PROFILE_ALLOCATE_OUTPUT(mIsVideo);
+    ExtendedStats::AutoProfile autoProfile(type, mPlayerExtendedStats);
+
+    if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
+        return allocateOutputBuffersFromNativeWindow();
+    }
+
+    if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {
+        ALOGE("protected output buffers must be stent to an ANativeWindow");
+        return PERMISSION_DENIED;
+    }
+
+    status_t err = OK;
+    if ((mFlags & kStoreMetaDataInVideoBuffers)
+            && portIndex == kPortIndexInput) {
+        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
+        if (err != OK) {
+            ALOGE("Storing meta data in video buffers is not supported");
+            return err;
+        }
+    }
+
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = portIndex;
+
+    err = mOMX->getParameter(
+            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+    if (err != OK) {
+        return err;
+    }
+
+    CODEC_LOGI("allocating %lu buffers of size %lu on %s port",
+            def.nBufferCountActual, def.nBufferSize,
+            portIndex == kPortIndexInput ? "input" : "output");
+
+    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
+        return BAD_VALUE;
+    }
+    size_t totalSize = def.nBufferCountActual * def.nBufferSize;
+    mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
+
+    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
+        sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
+        if (mem == NULL || mem->pointer() == NULL) {
+            return NO_MEMORY;
+        }
+
+        BufferInfo info;
+        info.mData = NULL;
+        info.mSize = def.nBufferSize;
+
+        IOMX::buffer_id buffer;
+        if (portIndex == kPortIndexInput
+                && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
+                    || (mFlags & kUseSecureInputBuffers))) {
+            if (mOMXLivesLocally) {
+                mem.clear();
+
+                err = mOMX->allocateBuffer(
+                        mNode, portIndex, def.nBufferSize, &buffer,
+                        &info.mData);
+            } else {
+                err = mOMX->allocateBufferWithBackup(
+                        mNode, portIndex, mem, &buffer);
+            }
+        } else if (portIndex == kPortIndexOutput
+                && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
+            if (mOMXLivesLocally) {
+                mem.clear();
+
+                err = mOMX->allocateBuffer(
+                        mNode, portIndex, def.nBufferSize, &buffer,
+                        &info.mData);
+            } else {
+                err = mOMX->allocateBufferWithBackup(
+                        mNode, portIndex, mem, &buffer);
+            }
+        } else {
+            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer);
         }
 
         if (err != OK) {
@@ -2234,6 +3168,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
     return OK;
 }
+#endif
 
 status_t OMXCodec::applyRotation() {
     sp<MetaData> meta = mSource->getFormat();
@@ -2277,29 +3212,25 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
-    setNativeWindowColorFormat(eNativeColorFormat);
-
-    err = native_window_set_buffers_geometry(
-    mNativeWindow.get(),
-    def.format.video.nFrameWidth,
-    def.format.video.nFrameHeight,
-    eNativeColorFormat);
-#elif defined(MTK_HARDWARE)
-    OMX_U32 frameWidth = def.format.video.nFrameWidth;
-    OMX_U32 frameHeight = def.format.video.nFrameHeight;
-
-    if (!strncmp("OMX.MTK.", mComponentName, 8)) {
-        frameWidth = def.format.video.nStride;
-        frameHeight = def.format.video.nSliceHeight;
+#ifndef USE_SAMSUNG_COLORFORMAT
+#ifdef MTK_HARDWARE
+// change the color/pixel format for JB blobs
+    uint32_t eHalColorFormat;
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatVendorMTKYUV:
+            eHalColorFormat = HAL_PIXEL_FORMAT_NV12_BLK;
+            break;
+        default:
+            eHalColorFormat = HAL_PIXEL_FORMAT_I420;
+            break;
     }
 
+    ALOGD ("native_window_set_buffers_geometry W(%d), H(%d), Stride(%d), SliceH(%d), eHalColorFormat(0x%08X)", def.format.video.nFrameWidth, def.format.video.nFrameHeight, def.format.video.nStride, def.format.video.nSliceHeight, eHalColorFormat);
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
-            frameWidth,
-            frameHeight,
-            def.format.video.eColorFormat);
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
+            eHalColorFormat);
 #else
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
@@ -2307,6 +3238,28 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
             def.format.video.nFrameHeight,
             def.format.video.eColorFormat);
 #endif
+#else
+    OMX_COLOR_FORMATTYPE eColorFormat;
+
+    switch (def.format.video.eColorFormat) {
+    case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
+        eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_SP_TILED;
+        break;
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
+        break;
+    case OMX_COLOR_FormatYUV420Planar:
+    default:
+        eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
+        break;
+    }
+
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+            def.format.video.nFrameWidth,
+            def.format.video.nFrameHeight,
+            eColorFormat);
+#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -2314,6 +3267,9 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+#ifdef MTK_HARDWARE
+    initNativeWindowCrop();
+#endif //MTK_HARDWARE
     err = applyRotation();
     if (err != OK) {
         return err;
@@ -2551,6 +3507,9 @@ OMXCodec::BufferInfo* OMXCodec::dequeueBufferFromNativeWindow() {
     if (err != 0) {
       CODEC_LOGE("dequeueBuffer failed w/ error 0x%08x", err);
 
+#ifdef MTK_HARDWARE
+      mFinalStatus = ERROR_BUFFER_DEQUEUE_FAIL;
+#endif
       setState(ERROR);
       return 0;
     }
@@ -2742,6 +3701,7 @@ int64_t OMXCodec::getDecodingTimeUs() {
 }
 
 void OMXCodec::on_message(const omx_message &msg) {
+#ifndef MTK_HARDWARE // remove Android 4.0 default code , Legis.
     if (mState == ERROR) {
         /*
          * only drop EVENT messages, EBD and FBD are still
@@ -2752,6 +3712,7 @@ void OMXCodec::on_message(const omx_message &msg) {
             return;
         }
     }
+#endif //MTK_HARDWARE
 
     switch (msg.type) {
         case omx_message::EVENT:
@@ -2787,6 +3748,16 @@ void OMXCodec::on_message(const omx_message &msg) {
 
             // Buffer could not be released until empty buffer done is called.
             if (info->mMediaBuffer != NULL) {
+
+#ifdef MTK_HARDWARE
+                if (mIsEncoder &&
+                    (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
+                    // If zero-copy mode is enabled this will send the
+                    // input buffer back to the upstream source.
+                    restorePatchedDataPointer(info);
+                }
+#endif
+
                 info->mMediaBuffer->release();
                 info->mMediaBuffer = NULL;
             }
@@ -2900,6 +3871,14 @@ void OMXCodec::on_message(const omx_message &msg) {
                 if (msg.u.extended_buffer_data.flags & OMX_BUFFERFLAG_EOS) {
                     CODEC_LOGV("No more output data.");
                     mNoMoreOutputData = true;
+#ifdef MTK_HARDWARE   //<---for omx component, the buffer flag is EOS, and buffer is empty.
+                    ALOGD ("OMXCodec::on_message EOS received!!!!");
+                    mTargetTimeUs=-1;
+                    if (0==msg.u.extended_buffer_data.range_length) {
+                        mBufferFilled.signal();
+                        break;
+                    }
+#endif //--->
                 }
 
                 if (mIsEncoder && mIsVideo) {
@@ -2908,9 +3887,17 @@ void OMXCodec::on_message(const omx_message &msg) {
                 }
 
                 if (mTargetTimeUs >= 0) {
+#ifdef MTK_HARDWARE
+					int64_t preRollDuration = systemTime() / 1000 - mPreRollStartTime;
+					ALOGD("Key time=%lld, Target time=%lld, Preroll time=%lld, Preroll duration=%lld",
+						msg.u.extended_buffer_data.timestamp, mTargetTimeUs, mPreRollStartTime, preRollDuration);
+					if ((msg.u.extended_buffer_data.timestamp < mTargetTimeUs) && (preRollDuration < kPreRollTimeOutUs))
+#else
                     CHECK(msg.u.extended_buffer_data.timestamp <= mTargetTimeUs);
 
-                    if (msg.u.extended_buffer_data.timestamp < mTargetTimeUs) {
+                    if (msg.u.extended_buffer_data.timestamp < mTargetTimeUs)
+#endif //MTK_HARDWARE
+ {
                         CODEC_LOGV(
                                 "skipping output buffer at timestamp %lld us",
                                 msg.u.extended_buffer_data.timestamp);
@@ -2925,6 +3912,9 @@ void OMXCodec::on_message(const omx_message &msg) {
                             "%lld us",
                             msg.u.extended_buffer_data.timestamp);
 
+#ifdef MTK_HARDWARE
+					mPreRollStartTime = -1;
+#endif //MTK_HARDWARE
                     mTargetTimeUs = -1;
                 }
 
@@ -3048,7 +4038,31 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
         {
             CODEC_LOGE("OMX_EventError(0x%08x, %u)", data1, data2);
 
+#ifdef MTK_HARDWARE
+            if((OMX_S32)data1 == OMX_ErrorStreamCorrupt)
+            {
+                ALOGW("OMXCodec::onEvent--OMX Error Stream Corrupt!!");
+                if(mIsVideoEncoder){
+                    ALOGW("OMXCodec::onEvent--Video encoder error");
+                    mFinalStatus = ERROR_UNSUPPORTED_VIDEO;
+            setState(ERROR);
+                }
+            }
+            else
+            {
+                if (mIsVideoDecoder && (OMX_S32)data1 == OMX_ErrorBadParameter) {
+                    ALOGW("OMXCodec::onEvent--OMX Bad Parameter!!");
+                    mFinalStatus = ERROR_UNSUPPORTED_VIDEO;
+                }
+				if(!mIsEncoder && !mIsVideoDecoder && (OMX_S32)data1 == OMX_ErrorBadParameter){
+					ALOGW("OMXCodec::onEvent--Audio OMX Bad Parameter!!");
+					mFinalStatus = ERROR_UNSUPPORTED_AUDIO;
+				}
+                setState(ERROR);
+            }
+#else
             setState(ERROR);
+#endif //MTK_HARDWARE
             break;
         }
 
@@ -3057,8 +4071,43 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
             CODEC_LOGV("OMX_EventPortSettingsChanged(port=%u, data2=0x%08x)",
                        data1, data2);
 
+#ifdef MTK_HARDWARE
+            if (data2 == 0 || data2 == OMX_IndexParamPortDefinition || data2 == OMX_IndexVendorMtkOmxVdecGetAspectRatio) {
+#else
             if (data2 == 0 || data2 == OMX_IndexParamPortDefinition) {
+#endif //MTK_HARDWARE
+                // There is no need to check whether mFilledBuffers is empty or not
+                // when the OMX_EventPortSettingsChanged is not meant for reallocating
+                // the output buffers.
+                if (data1 == kPortIndexOutput) {
+#ifdef MTK_HARDWARE
+                    mFilledBuffers.clear();
+#else
+                    CHECK(mFilledBuffers.empty());
+#endif //MTK_HARDWARE
+                }
+#ifdef MTK_HARDWARE
+                if (mState == EXECUTING_TO_IDLE)//Bruce, do nothing after stop
+                {
+                    ALOGE("Get port_setting_changed_event after stop!");
+                    break;
+                }
+                onPortSettingsChanged(data1);
+#else
                 onPortSettingsChanged(data1);
+#endif //MTK_HARDWARE
+
+            #ifdef MTK_HARDWARE
+                if (data2 == OMX_IndexVendorMtkOmxVdecGetAspectRatio) {
+                    ALOGE ("@@ GOT OMX_IndexVendorMtkOmxVdecGetAspectRatio");
+                    OMX_S32 aspectRatio = 0;
+                    if (OK == mOMX->getConfig(mNode, OMX_IndexVendorMtkOmxVdecGetAspectRatio, &aspectRatio, sizeof(aspectRatio))) {
+                        ALOGE ("@@ AspectRatioWidth (%d), AspectRatioHeight(%d)", (aspectRatio & 0xFFFF0000) >> 16, (aspectRatio & 0x0000FFFF));
+                        mVideoAspectRatioWidth = ((aspectRatio & 0xFFFF0000) >> 16);
+                        mVideoAspectRatioHeight = (aspectRatio & 0x0000FFFF);
+                    }
+                }
+            #endif
             } else if (data1 == kPortIndexOutput &&
                         (data2 == OMX_IndexConfigCommonOutputCrop ||
                          data2 == OMX_IndexConfigCommonScale)) {
@@ -3337,7 +4386,13 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
 
                 setState(IDLE_TO_EXECUTING);
             } else {
+#ifdef MTK_HARDWARE // modify Android 4.0 default code , Legis.
+                if (mState != ERROR) {
+#endif //MTK_HARDWARE
                 CHECK_EQ((int)mState, (int)EXECUTING_TO_IDLE);
+#ifdef MTK_HARDWARE // modify Android 4.0 default code , Legis.
+                }
+#endif //MTK_HARDWARE
 
                 if (countBuffersWeOwn(mPortBuffers[kPortIndexInput]) !=
                     mPortBuffers[kPortIndexInput].size()) {
@@ -3473,7 +4528,11 @@ status_t OMXCodec::freeBuffersOnPort(
     for (size_t i = buffers->size(); i-- > 0;) {
         BufferInfo *info = &buffers->editItemAt(i);
 
+#ifdef MTK_HARDWARE
+        if (onlyThoseWeOwn && (info->mStatus == OWNED_BY_COMPONENT || info->mStatus == OWNED_BY_CLIENT)) {
+#else
         if (onlyThoseWeOwn && info->mStatus == OWNED_BY_COMPONENT) {
+#endif
             continue;
         }
 
@@ -3565,6 +4624,11 @@ bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
         CHECK_EQ((int)mPortStatus[portIndex], (int)ENABLED);
         mPortStatus[portIndex] = SHUTTING_DOWN;
 
+#ifdef MTK_HARDWARE
+    if (mQueueWaiting && kPortIndexOutput == portIndex) {
+        mBufferSent.signal();
+    }
+#endif //MTK_HARDWARE
         if ((mQuirks & kRequiresFlushCompleteEmulation)
             && countBuffersWeOwn(mPortBuffers[portIndex])
                 == mPortBuffers[portIndex].size()) {
@@ -3647,7 +4711,11 @@ void OMXCodec::drainInputBuffers() {
     if (mFlags & kUseSecureInputBuffers) {
         Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
         for (size_t i = 0; i < buffers->size(); ++i) {
+#ifdef MTK_HARDWARE
+            if (!drainAnyInputBuffer(true)
+#else
             if (!drainAnyInputBuffer()
+#endif
                     || (mFlags & kOnlySubmitOneInputBufferAtOneTime)) {
                 break;
             }
@@ -3661,7 +4729,11 @@ void OMXCodec::drainInputBuffers() {
                 continue;
             }
 
+#ifdef MTK_HARDWARE
+            if (!drainInputBuffer(info, true)) {
+#else
             if (!drainInputBuffer(info)) {
+#endif
                 break;
             }
 
@@ -3672,9 +4744,41 @@ void OMXCodec::drainInputBuffers() {
     }
 }
 
+#ifdef MTK_HARDWARE
+bool OMXCodec::drainAnyInputBuffer(bool init) {
+    return drainInputBuffer((BufferInfo *)NULL, init);
+}
+#else
 bool OMXCodec::drainAnyInputBuffer() {
     return drainInputBuffer((BufferInfo *)NULL);
 }
+#endif
+
+#ifdef MTK_HARDWARE
+void OMXCodec::PutErrorPatterns(uint8_t *pBuffer, uint32_t length) {
+    int error_count = 0;
+    int _RAND_LIMIT = 32768;
+    srand(time(0));
+    for(int i = 0 ; i < length ; i++) {
+        int error_mask = 0;
+        float rand_num;
+        for(int j = 0; j < 8; j++) {
+            rand_num = (float)((rand()%_RAND_LIMIT)*_RAND_LIMIT+(rand()%_RAND_LIMIT))/((float)_RAND_LIMIT)/((float)_RAND_LIMIT);
+
+            if(rand_num > 1)
+                CHECK(false); // assert
+
+            if(rand_num < mVideoInputErrorRate)
+		    error_count++;
+
+		error_mask += (rand_num < mVideoInputErrorRate);
+		error_mask <<= 1;
+        }
+
+        pBuffer[i] ^= (uint8_t) error_mask;
+    }
+}
+#endif
 
 OMXCodec::BufferInfo *OMXCodec::findInputBufferByDataPointer(void *ptr) {
     Vector<BufferInfo> *infos = &mPortBuffers[kPortIndexInput];
@@ -3707,7 +4811,11 @@ OMXCodec::BufferInfo *OMXCodec::findEmptyInputBuffer() {
     TRESPASS();
 }
 
+#ifdef MTK_HARDWARE
+bool OMXCodec::drainInputBuffer(BufferInfo *info, bool init) {
+#else
 bool OMXCodec::drainInputBuffer(BufferInfo *info) {
+#endif
     ATRACE_CALL();
     if (info != NULL) {
         CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
@@ -3765,6 +4873,10 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     status_t err;
 
+#ifdef MTK_HARDWARE
+    bool isPartialFrame = false;
+    bool reComputePTS = false;
+#endif //MTK_HARDWARE
     bool signalEOS = false;
     int64_t timestampUs = 0;
 
@@ -3809,7 +4921,53 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
             err = OK;
         } else {
+#ifdef MTK_HARDWARE
+            // if we have enough output buffers, pause pulling source
+            if (mMaxQueueBufferNum > 0 && !init) {
+                // mLock must be held to get here
+                while ((mFilledBuffers.size() > mMaxQueueBufferNum) &&
+                        (mState == EXECUTING || mState == RECONFIGURING)) {
+                    mQueueWaiting = true;
+                    status_t err = mBufferSent.waitRelative(mLock, 10000000000LL);
+                    if (err == -ETIMEDOUT) {
+                        ALOGI("drainInputBuffer wait timeout with state %d, seek %lld",
+                                mState, mSeekTimeUs);
+                    }
+                }
+                mQueueWaiting = false;
+                if (mSeekTimeUs >= 0 ||
+                        (mState != EXECUTING && mState != RECONFIGURING)) {
+                    // seek/stop during waiting
+                    ALOGD("drainInputBuffer break with state %d, seek %lld",
+                            mState, mSeekTimeUs);
+                    return false;
+                }
+                mLock.unlock();
+                // mSource is safe here because AwesomePlayer calls stop before dtor
+            err = mSource->read(&srcBuffer);
+                mLock.lock();
+            } else
+#endif // #ifdef MTK_HARDWARE
+#ifdef MTK_HARDWARE
+            {
+                if (mIsVideoDecoder && !mIsHttpStreaming) {
+                     mLock.unlock();
+        }
+#endif
             err = mSource->read(&srcBuffer);
+#ifdef MTK_HARDWARE
+                if (mIsVideoDecoder && !mIsHttpStreaming) {
+                    mLock.lock();
+                 }
+            }
+#endif
+
+#ifdef MTK_HARDWARE
+            if(mNoMoreOutputData)
+            {
+                CODEC_LOGE("Read source after no more output data done, err=0x%08x", err);//for EOS may hang
+        }
+#endif 
         }
 
         if (err != OK) {
@@ -3817,6 +4975,18 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
             mFinalStatus = err;
             mSignalledEOS = true;
             mBufferFilled.signal();
+//deal time out MTK80721 2012-03-29
+#ifdef MTK_HARDWARE
+            if ((!strncmp(mComponentName, "OMX.MTK.AUDIO.ENCODER", 21)  && err== TIMED_OUT))
+            {
+                ALOGE("OMXCodec::drainInputBuffer: time out,tid=%d",gettid());
+                srcBuffer->release();
+                srcBuffer = NULL;
+                setState(ERROR);
+                return false;
+            }
+#endif //MTK_HARDWARE
+//
             break;
         }
 
@@ -3831,7 +5001,12 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         size_t remainingBytes = info->mSize - offset;
 
         if (srcBuffer->range_length() > remainingBytes) {
+#ifdef MTK_HARDWARE
+            // don't fail if codec supports partial frames
+            if (offset == 0 && !mSupportsPartialFrames) {
+#else //MTK_HARDWARE
             if (offset == 0) {
+#endif //MTK_HARDWARE
                 CODEC_LOGE(
                      "Codec's input buffers are too small to accomodate "
                      "buffer read from source (info->mSize = %d, srcLength = %d)",
@@ -3844,11 +5019,51 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                 return false;
             }
 
+#ifdef MTK_HARDWARE
+            if (offset != 0) {
+            mLeftOverBuffer = srcBuffer;
+            break;
+        }
+            ALOGD("OMXCodec: split big input buffer %d to %d",
+                    srcBuffer->range_length(), remainingBytes);
+            // split input buffer
+            bool needOwner = srcBuffer->refcount() == 0;
+            mLeftOverBuffer = srcBuffer;
+            srcBuffer = mLeftOverBuffer->clone();
+            srcBuffer->set_range(mLeftOverBuffer->range_offset(), remainingBytes);
+            mLeftOverBuffer->set_range(mLeftOverBuffer->range_offset() + remainingBytes,
+                    mLeftOverBuffer->range_length() - remainingBytes);
+            if (needOwner) {
+                // make a owner for MediaBuffer to help release
+                mLeftOverBuffer->setObserver(&this->mOMXPartialBufferOwner);
+                mLeftOverBuffer->add_ref();
+            }
+            isPartialFrame = true;
+#else
             mLeftOverBuffer = srcBuffer;
             break;
+#endif // #ifdef MTK_HARDWARE
         }
 
         bool releaseBuffer = true;
+
+#ifdef MTK_HARDWARE
+        if (mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
+                CHECK(mOMXLivesLocally && offset == 0);
+
+                OMX_BUFFERHEADERTYPE *header =
+                    (OMX_BUFFERHEADERTYPE *)info->mBuffer;
+
+                CHECK(header->pBuffer == info->mData);
+
+                header->pBuffer =
+                    (OMX_U8 *)srcBuffer->data() + srcBuffer->range_offset();
+
+                releaseBuffer = false;
+                info->mMediaBuffer = srcBuffer;
+#endif
+        } else {
+
         if (mFlags & kStoreMetaDataInVideoBuffers) {
                 releaseBuffer = false;
                 info->mMediaBuffer = srcBuffer;
@@ -3903,9 +5118,26 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                         + srcBuffer->range_offset(),
                     srcBuffer->range_length());
 #endif // USE_SAMSUNG_COLORFORMAT
+#ifdef MTK_HARDWARE
+            if ((mPropFlags & OMXCODEC_ENABLE_VIDEO_INPUT_ERROR_PATTERNS) && mIsVideoDecoder) {
+                PutErrorPatterns((uint8_t *)info->mData + offset, srcBuffer->range_length());
+        }
+
+            //ALOGD ("@@ memcpy info->mData(0x%08X), offset(%d), range_offset(%d), range_length(%d)", info->mData, offset, srcBuffer->range_offset(), srcBuffer->range_length());
+#endif //MTK_HARDWARE
+        }
+#ifdef MTK_HARDWARE
         }
 
+#endif //MTK_HARDWARE
         int64_t lastBufferTimeUs;
+#ifdef MTK_HARDWARE
+        // MTK decoders sporadically don't set the time in some buffers
+        if (!(srcBuffer->meta_data()->findInt64(kKeyTime, &lastBufferTimeUs))) {
+            lastBufferTimeUs = 0;
+            srcBuffer->meta_data()->setInt64(kKeyTime, lastBufferTimeUs);
+        }
+#endif
         CHECK(srcBuffer->meta_data()->findInt64(kKeyTime, &lastBufferTimeUs));
         CHECK(lastBufferTimeUs >= 0);
 
@@ -3981,9 +5213,10 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;
 
-    if(interlaceFormatDetected) {
-	interlaceFrameCount++;
-    }
+#ifdef MTK_HARDWARE
+    if (isPartialFrame)
+        flags = 0;
+#endif //MTK_HARDWARE
 
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
@@ -4004,6 +5237,10 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         mNoMoreOutputData = false;
     }
 
+#ifdef MTK_HARDWARE
+    if (reComputePTS)
+        flags |= OMX_BUFFERFLAG_INVALID_TIMESTAMP;
+#endif //MTK_HARDWARE
     if (info == NULL) {
         CHECK(mFlags & kUseSecureInputBuffers);
         CHECK(signalEOS);
@@ -4013,6 +5250,12 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         // to use it to signal EOS to the codec.
         info = findEmptyInputBuffer();
     }
+#ifdef MTK_HARDWARE
+    if (mPortStatus[kPortIndexInput] == SHUTTING_DOWN) {
+        CODEC_LOGI("input port in shutdown mode");
+        return false;
+    }
+#endif //MTK_HARDWARE
 
     PLAYER_STATS(profileStartOnce, STATS_PROFILE_FIRST_BUFFER(mIsVideo));
     CODEC_LOGV("Calling emptyBuffer on buffer %p (length %d), "
@@ -4099,7 +5342,33 @@ status_t OMXCodec::waitForBufferFilled_l() {
         // for video encoding.
         return mBufferFilled.wait(mLock);
     }
+#ifdef MTK_HARDWARE
+
+    //if (!strncmp("OMX.MTK.VIDEO.DECODER", mComponentName, 21))
+	{
+        CODEC_LOGE("+waitForBufferFilled_l: %d/%d",
+            countBuffersWeOwn(mPortBuffers[kPortIndexInput]),
+            countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));//for EOS may hang
+    }
+
+    status_t err;
+    if (mRTSPOutputTimeoutUS != -1) {
+	CODEC_LOGI("output buf time out %lld us for rtsp.", mRTSPOutputTimeoutUS);
+	err = mBufferFilled.waitRelative(mLock, mRTSPOutputTimeoutUS);
+    }
+    else if (mHTTPOutputTimeoutUS != -1) {
+	CODEC_LOGI("output buf time out %lld us for http.", mHTTPOutputTimeoutUS);
+	err = mBufferFilled.waitRelative(mLock, mHTTPOutputTimeoutUS);
+    }
+    else if (!strncmp(mComponentName, "OMX.MTK.VIDEO.DECODER", 21)) {
+	err = mBufferFilled.waitRelative(mLock, VDeckBufferFilledEventTimeOutNs);
+    }
+    else {
+	err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNs);
+    }
+#else //MTK_HARDWARE
     status_t err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNs);
+#endif
     if ((err == -ETIMEDOUT) && (mPaused == true)){
         // When the audio playback is paused, the fill buffer maybe timed out
         // if input data is not available to decode. Hence, considering the
@@ -4111,6 +5380,12 @@ status_t OMXCodec::waitForBufferFilled_l() {
             countBuffersWeOwn(mPortBuffers[kPortIndexInput]),
             countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
     }
+#ifdef MTK_HARDWARE
+   // if (!strncmp("OMX.MTK.VIDEO.DECODER", mComponentName, 21))
+   {
+        CODEC_LOGE("-waitForBufferFilled_l");//for EOS may hang
+    }
+#endif //MTK_HARDWARE
     return err;
 }
 
@@ -4500,6 +5775,60 @@ status_t OMXCodec::start(MetaData *meta) {
             startTimeUs = timeUs;
         }
         params->setInt64(kKeyTime, startTimeUs);
+#ifdef MTK_HARDWARE
+	int32_t isHttpStreaming = 0;
+	if (meta->findInt32(kKeyIsHTTPStreaming, &isHttpStreaming) && isHttpStreaming) {
+	    mIsHttpStreaming = true;
+	    ALOGD ("@@ mIsHttpStreaming (%d)", mIsHttpStreaming);
+	}
+
+        int32_t mode;
+        if (meta->findInt32(kKeyRTSPSeekMode, &mode) && mode != 0) {
+            status_t err2 = OK;
+            OMX_INDEXTYPE index = OMX_IndexMax;
+            status_t err = mOMX->getExtensionIndex(mNode, "OMX.MTK.index.param.video.StreamingMode", &index);
+            if (err == OK) {
+                OMX_BOOL m = OMX_TRUE;
+                err2 = mOMX->setParameter(mNode, index, &m, sizeof(m));
+            }
+            ALOGI("set StreamingMode, index = %x, err = %x, err2 = %x", index, err, err2);
+        }
+	// mtk80902: ALPS00390150
+	int64_t to;
+	if (meta->findInt64(kKeyRTSPOutputTimeoutUS, &to) && to != 0) {
+	    ALOGI("set output buffer timeout %lld for rtsp.", to);
+	    mRTSPOutputTimeoutUS = to;
+	}
+	if (meta->findInt64(kKeyHTTPOutputTimeoutUS, &to) && to != 0) {
+	    ALOGI("set output buffer timeout %lld for http.", to);
+	    mHTTPOutputTimeoutUS = to;
+	}
+        int32_t number = -1;
+        if (meta->findInt32(kKeyMaxQueueBuffer, &number) && number > 0) {
+            mMaxQueueBufferNum = number;
+        }
+        if (meta->findInt32(kKeyInputBufferNum, &number) && number > 0) {
+            OMX_PARAM_PORTDEFINITIONTYPE def;
+            InitOMXParams(&def);
+            def.nPortIndex = kPortIndexInput;
+
+            status_t err = mOMX->getParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            CHECK_EQ((int)err, (int)OK);
+
+            def.nBufferCountActual = number > (int32_t)def.nBufferCountMin
+                ? number : def.nBufferCountMin;
+
+            err = mOMX->setParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            CHECK_EQ((int)err, (int)OK);
+
+            err = mOMX->getParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            CHECK_EQ((int)err, (int)OK);
+
+        }
+#endif // #ifdef MTK_HARDWARE
     }
 
     mCodecSpecificDataIndex = 0;
@@ -4513,6 +5842,46 @@ status_t OMXCodec::start(MetaData *meta) {
     mFilledBuffers.clear();
     mPaused = false;
 
+#ifdef MTK_HARDWARE
+    if (mIsEncoder) {
+    	status_t err;
+        if ((err = init()) != OK) {
+            CODEC_LOGE("init failed: %d", err);
+            return err;
+        }
+        params->setInt32(kKeyNumBuffers, mPortBuffers[kPortIndexInput].size());
+        err = mSource->start(params.get());
+        if (err != OK) {
+            CODEC_LOGE("source failed to start: %d", err);
+            stopOmxComponent_l();
+        }
+        return err;
+    }
+    status_t err = mSource->start(params.get());
+
+    if (err != OK) {
+        return err;
+    }
+    if (!strncmp("OMX.MTK.", mComponentName, 8)) {
+        OMX_BOOL value;
+        // check if codec supports partial frames input
+        status_t err = mOMX->getParameter(mNode,
+                (OMX_INDEXTYPE)OMX_IndexVendorMtkOmxPartialFrameQuerySupported,
+                &value, sizeof(value));
+        mSupportsPartialFrames = value;
+        if (err != OK) {
+            mSupportsPartialFrames = false;
+        }
+        ALOGI("mSupportsPartialFrames %d err %d ", mSupportsPartialFrames, err);
+    }
+
+    err = init();
+    if (err != OK) {
+	ALOGE("line=%d,err:%d,init fail,stop mSource",__LINE__, err);
+	mSource->stop();
+    }
+    return err;
+#else //MTK_HARDWARE
     status_t err;
     if (mIsEncoder) {
         // Calling init() before starting its source so that we can configure,
@@ -4546,6 +5915,7 @@ status_t OMXCodec::start(MetaData *meta) {
         stopOmxComponent_l();
     }
     return err;
+#endif //MTK_HARDWARE
 }
 
 status_t OMXCodec::stop() {
@@ -4637,6 +6007,10 @@ status_t OMXCodec::stopOmxComponent_l() {
                 mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
                 mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
 
+#ifdef MTK_HARDWARE
+                if (mQueueWaiting)
+                    mBufferSent.signal();
+#endif // #ifdef MTK_HARDWARE
                 status_t err =
                     mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
                 CHECK_EQ(err, (status_t)OK);
@@ -4676,6 +6050,103 @@ sp<MetaData> OMXCodec::getFormat() {
     return mOutputFormat;
 }
 
+#ifdef MTK_HARDWARE  // for Camera recording
+sp<MetaData> OMXCodec::getCameraMeta() {
+    Mutex::Autolock autoLock(mLock);
+
+    return mCameraMeta;
+}
+
+status_t OMXCodec::vEncSetForceIframe(bool enable) {
+    if (mIsVideoEncoder) {
+        if (!strncmp(mComponentName, "OMX.MTK.", 8)) {
+            OMX_INDEXTYPE index;
+            status_t err =
+            mOMX->getExtensionIndex(
+                    mNode,
+                    "OMX.MTK.index.param.video.EncSetForceIframe",
+                    &index);
+
+            if (err != OK) {
+                return err;
+            }
+
+            OMX_BOOL enable = OMX_TRUE;
+            err = mOMX->setConfig(mNode, index, &enable, sizeof(enable));
+
+            if (err != OK) {
+                CODEC_LOGE("setConfig('OMX.MTK.index.param.video.EncSetForceIframe') returned error 0x%08x", err);
+                return err;
+            }
+        }
+    }
+
+    return OK;
+}
+
+#ifdef MTK_HARDWARE
+// for dynamic bit-rate adjustment [
+status_t OMXCodec::vEncSetBitRate(unsigned int u4BitRate) {
+
+    OMX_VIDEO_CONFIG_BITRATETYPE ConfigBitrate;
+    status_t err;
+
+    if (mIsVideoEncoder) {
+        //CODEC_LOGE("@@@>> set bit rate >> %d",u4BitRate);
+        ConfigBitrate.nEncodeBitrate = u4BitRate;
+        ConfigBitrate.nPortIndex = kPortIndexOutput;
+        err = mOMX->setConfig(mNode, OMX_IndexConfigVideoBitrate, &ConfigBitrate, sizeof(OMX_VIDEO_CONFIG_BITRATETYPE));
+        if (err != OK) {
+            CODEC_LOGE("Fail to adjust bit-rate, returned error 0x%08x", err);
+            return err;
+        }
+    }
+    return OK;
+}
+// ]
+
+status_t OMXCodec::vDecSwitchBwTVout(bool enable) {   // true: w/ tvout,  false: w/o tvout
+    if (mIsVideoDecoder) {
+        if (!strncmp(mComponentName, "OMX.MTK.", 8)) {
+            OMX_INDEXTYPE index;
+            status_t err =
+            mOMX->getExtensionIndex(
+                    mNode,
+                    "OMX.MTK.index.param.video.SwitchBwTVout",
+                    &index);
+
+            if (err != OK) {
+                return err;
+            }
+
+            OMX_BOOL enable = (OMX_BOOL)enable;
+            err = mOMX->setConfig(mNode, index, &enable, sizeof(enable));
+
+            if (err != OK) {
+                CODEC_LOGE("setConfig('OMX.MTK.index.param.video.SwitchBwTVout') returned error 0x%08x", err);
+                return err;
+            }
+        }
+    }
+    return OK;
+}
+#endif //MTK_HARDWARE
+
+size_t OMXCodec::buffersOwn() {
+    const Vector<BufferInfo> &buffers = mPortBuffers[kPortIndexOutput];
+    size_t n = 0;
+    for (size_t i = 0; i < buffers.size(); ++i) {
+        if (buffers[i].mStatus == OWNED_BY_US) {
+            ++n;
+        }
+    }
+
+    return n;
+}
+
+
+#endif
+
 status_t OMXCodec::read(
         MediaBuffer **buffer, const ReadOptions *options) {
     ATRACE_CALL();
@@ -4693,6 +6164,10 @@ status_t OMXCodec::read(
     }
 
     if (mState != EXECUTING && mState != RECONFIGURING) {
+#ifdef MTK_HARDWARE
+        if (mState == ERROR && ((mFinalStatus == ERROR_UNSUPPORTED_VIDEO) || (mFinalStatus == ERROR_UNSUPPORTED_AUDIO) || (mFinalStatus == ERROR_BUFFER_DEQUEUE_FAIL)))
+            return mFinalStatus;
+#endif
         return UNKNOWN_ERROR;
     }
 
@@ -4701,6 +6176,10 @@ status_t OMXCodec::read(
     ReadOptions::SeekMode seekMode;
     if (options && options->getSeekTo(&seekTimeUs, &seekMode)) {
         seeking = true;
+#ifdef MTK_HARDWARE
+		mPreRollStartTime = systemTime() / 1000;
+		CODEC_LOGI("mPreRollStartTime = %lld", mPreRollStartTime);
+#endif //MTK_HARDWARE
     }
 
     if (mInitialBufferSubmit) {
@@ -4717,13 +6196,50 @@ status_t OMXCodec::read(
             mPaused = false;
         }
 
+#ifdef MTK_HARDWARE  // Morris Yang for Camera recording
+        if (mCameraMeta.get() != NULL) {
+            int32_t _initial_submit_count = 0;
+            int32_t _initial_submit_limit = 2;
+            if (mIsVENCTimelapseMode) {
+            	_initial_submit_limit = 1;
+            	ALOGD ("Submit one frame for timelapse mode!!");
+            }
+            Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
+            for (size_t i = 0; i < buffers->size(); ++i) {
+                BufferInfo *info = &buffers->editItemAt(i);
+
+                if (info->mStatus != OWNED_BY_US) {
+                    continue;
+                }
+
+                if (!drainInputBuffer(info, true)) {
+                    break;
+                }
+
+                _initial_submit_count++;
+                if (_initial_submit_count == _initial_submit_limit) {
+                    break;
+                }
+            }
+        }
+        else {
+            drainInputBuffers();
+        }
+#endif
 
         if (mState == EXECUTING) {
             // Otherwise mState == RECONFIGURING and this code will trigger
             // after the output port is reenabled.
             fillOutputBuffers();
         }
+
         drainInputBuffers();
+        if (seeking) {
+#ifdef MTK_HARDWARE
+            OMX_TICKS seekTime = seekTimeUs;
+            mOMX->setConfig(mNode, OMX_IndexVendorMtkOmxVdecSeekMode, (void *)&seekTime, sizeof(void *));
+#endif //MTK_HARDWARE
+        }
     }
 
     if (seeking) {
@@ -4734,6 +6250,10 @@ status_t OMXCodec::read(
         }
 
         if (mState != EXECUTING) {
+#ifdef MTK_HARDWARE
+            if (mState == ERROR && ((mFinalStatus == ERROR_UNSUPPORTED_VIDEO) || (mFinalStatus == ERROR_UNSUPPORTED_AUDIO)))
+                return mFinalStatus;
+#endif //MTK_HARDWARE
             return UNKNOWN_ERROR;
         }
 
@@ -4745,6 +6265,17 @@ status_t OMXCodec::read(
         mSeekTimeUs = seekTimeUs;
         mSeekMode = seekMode;
 
+#ifdef MTK_HARDWARE
+        //Bruce Hsu resend SPS and PPS for AVC after seek
+        if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME))
+        {
+            mCodecSpecificDataIndex = 0;
+            if(mCodecSpecificData.size() != 2)
+            {
+                ALOGE("Resend unexpected data, %d!!", mCodecSpecificData.size());
+            }
+        }
+#endif //MTK_HARDWARE
         mFilledBuffers.clear();
 
         CHECK_EQ((int)mState, (int)EXECUTING);
@@ -4776,6 +6307,10 @@ status_t OMXCodec::read(
                 if (emulateOutputFlushCompletion) {
                     onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
                 }
+#ifdef MTK_HARDWARE
+        OMX_TICKS seekTime = seekTimeUs;
+        mOMX->setConfig(mNode, OMX_IndexVendorMtkOmxVdecSeekMode, (void *)&seekTime, sizeof(void *));
+#endif //MTK_HARDWARE
             }
         }
 
@@ -4783,6 +6318,19 @@ status_t OMXCodec::read(
             if ((err = waitForBufferFilled_l()) != OK) {
                 return err;
             }
+#ifdef MTK_HARDWARE
+            size_t index = *mFilledBuffers.begin();
+            if (!mFilledBuffers.empty() && mPortBuffers[kPortIndexOutput].size() > 0 && index < mPortBuffers[kPortIndexOutput].size()) {
+                BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(index);
+                MediaBuffer *buffer = info->mMediaBuffer;
+                if (buffer && buffer->range_length() == 0 && info->mStatus == OWNED_BY_US) { // invalid buffer and return
+                    mFilledBuffers.erase(mFilledBuffers.begin());
+                    CODEC_LOGV("output buffer length 0 return to omx directly");
+                    fillOutputBuffer(info);
+        }
+    }
+
+#endif //MTK_HARDWARE
         }
     }
 
@@ -4799,9 +6347,21 @@ status_t OMXCodec::read(
     }
 
     if (mState == ERROR) {
+#ifdef MTK_HARDWARE
+        if ((mFinalStatus == ERROR_UNSUPPORTED_VIDEO) || (mFinalStatus == ERROR_UNSUPPORTED_AUDIO))
+            return mFinalStatus;
+#endif //MTK_HARDWARE
         return UNKNOWN_ERROR;
     }
 
+#ifdef MTK_HARDWARE
+	if (mOutputPortSettingsHaveChanged) {
+		mOutputPortSettingsHaveChanged = false;
+		ALOGD("INFO_FORMAT_CHANGED");
+		return INFO_FORMAT_CHANGED;
+	}
+#endif //MTK_HARDWARE
+
     if (seeking) {
         CHECK_EQ((int)mState, (int)FLUSHING);
         setState(EXECUTING);
@@ -4818,12 +6378,20 @@ status_t OMXCodec::read(
     }
 
     size_t index = *mFilledBuffers.begin();
+#ifdef MTK_HARDWARE
+	Vector<BufferInfo> *buftest = &mPortBuffers[kPortIndexOutput];
+	CHECK(index < buftest->size());
+#endif //MTK_HARDWARE
     mFilledBuffers.erase(mFilledBuffers.begin());
     if (!strncasecmp(mMIME, "video/", 6)) {
         ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
         ATRACE_INT("Output Buffers with OMX client",
                 countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
     }
+#ifdef MTK_HARDWARE
+    if (mQueueWaiting)
+        mBufferSent.signal();
+#endif //MTK_HARDWARE
 
     BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(index);
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
@@ -4836,9 +6404,18 @@ status_t OMXCodec::read(
     *buffer = info->mMediaBuffer;
 
 #ifndef MTK_HARDWARE
-    if (info->mOutputCropChanged) {
-        initNativeWindowCrop();
-        info->mOutputCropChanged = false;
+    if ((mFlags & kUseMaxOutputBuffers) && (mNativeWindow != NULL) && mIsVideo) {
+        int32_t left, top, right, bottom;
+        CHECK(mOutputFormat->findRect(kKeyCropRect, &left, &top, &right, &bottom));
+        OMX_BUFFERHEADERTYPE *pBufferHeader = static_cast<OMX_BUFFERHEADERTYPE *>(info->mBuffer);
+        if (((pBufferHeader->nWidth != right - left) || (pBufferHeader->nHeight != bottom - top)) && pBufferHeader->nFilledLen > 0) {
+            android_native_rect_t crop;
+            crop.left = left;
+            crop.top = top;
+            crop.right = left + pBufferHeader->nWidth + 1;
+            crop.bottom = top + pBufferHeader->nHeight + 1;
+            native_window_set_crop(mNativeWindow.get(), &crop);
+        }
     }
 #endif
 #ifdef DOLBY_UDC
@@ -4860,11 +6437,24 @@ void OMXCodec::signalBufferReturned(MediaBuffer *buffer) {
         BufferInfo *info = &buffers->editItemAt(i);
 
         if (info->mMediaBuffer == buffer) {
+#ifdef MTK_HARDWARE
+            if (mState != RECONFIGURING) {
+            CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)ENABLED);
+            }
+#else //MTK_HARDWARE
             CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)ENABLED);
+#endif //MTK_HARDWARE
             CHECK_EQ((int)info->mStatus, (int)OWNED_BY_CLIENT);
 
             info->mStatus = OWNED_BY_US;
 
+#ifdef MTK_HARDWARE
+            if (mState == RECONFIGURING) {
+                CODEC_LOGE("freeBuffer from signalBufferReturned");
+                freeBuffer(kPortIndexOutput, i);
+            }
+            else {
+#endif //MTK_HARDWARE
             if (buffer->graphicBuffer() == 0) {
                 fillOutputBuffer(info);
             } else {
@@ -4891,6 +6481,9 @@ void OMXCodec::signalBufferReturned(MediaBuffer *buffer) {
                 // Give the buffer to the OMX node to fill.
                 fillOutputBuffer(nextBufInfo);
             }
+#ifdef MTK_HARDWARE
+            }
+#endif //MTK_HARDWARE
             return;
         }
     }
@@ -5156,6 +6749,11 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 inputFormat->findInt32(kKeyChannelCount, &numChannels);
                 inputFormat->findInt32(kKeySampleRate, &sampleRate);
                 inputFormat->findInt32(kKeyBitRate, &bitRate);
+#ifdef MTK_HARDWARE
+                int32_t aacProfile = OMX_AUDIO_AACObjectLC;
+                inputFormat->findInt32(kKeyAACProfile, &aacProfile);
+                mOutputFormat->setInt32(kKeyAACProfile, aacProfile);
+#endif //MTK_HARDWARE
                 mOutputFormat->setInt32(kKeyChannelCount, numChannels);
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
@@ -5214,6 +6812,11 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
             } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingAVC) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
+#ifdef MTK_HARDWARE
+            } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingVP8) {
+                mOutputFormat->setCString(
+                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_VP8);
+#endif //MTK_HARDWARE
             } else {
                 AString mimeType;
                 err = BAD_VALUE;
@@ -5234,9 +6837,12 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
 
             mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
-            mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
+#ifdef MTK_HARDWARE
+// Decompiled JB libstagefright.so don't have this 2: we must investigate why
             mOutputFormat->setInt32(kKeyStride, video_def->nStride);
             mOutputFormat->setInt32(kKeySliceHeight, video_def->nSliceHeight);
+#endif
+            mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
 
             if (!mIsEncoder) {
                 OMX_CONFIG_RECTTYPE rect;
@@ -5305,6 +6911,12 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
     if (mSource->getFormat()->findInt32(kKeyRotation, &rotationDegrees)) {
         mOutputFormat->setInt32(kKeyRotation, rotationDegrees);
     }
+#ifdef MTK_HARDWARE
+    if (mIsVideoDecoder) {
+        mOutputFormat->setInt32(kKeyAspectRatioWidth, mVideoAspectRatioWidth);
+        mOutputFormat->setInt32(kKeyAspectRatioHeight, mVideoAspectRatioHeight);
+    }
+#endif //MTK_HARDWARE
 }
 
 status_t OMXCodec::pause() {
@@ -5367,8 +6979,26 @@ status_t OMXCodec::resumeLocked(bool drainInputBuf) {
         return OK;
     }
 }
+#ifdef MTK_HARDWARE
+void OMXCodec::resume() {
+    Mutex::Autolock autoLock(mLock);
+
+    CODEC_LOGE("RESUME--------------------");
+    mPaused = false;
+
+}
+#endif //MTK_HARDWARE
 
 ////////////////////////////////////////////////////////////////////////////////
+#ifdef MTK_HARDWARE
+void OMXCodec::restorePatchedDataPointer(BufferInfo *info) {
+    CHECK(mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames));
+    CHECK(mOMXLivesLocally);
+
+    OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)info->mBuffer;
+    header->pBuffer = (OMX_U8 *)info->mData;
+}
+#endif
 
 status_t QueryCodecs(
         const sp<IOMX> &omx,
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 37b21a25c..937034b7f 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -38,6 +38,22 @@
 #include <gralloc_priv.h>
 #endif
 
+#ifdef MTK_HARDWARE
+#include <cutils/properties.h>
+#include <SkImageEncoder.h>
+#include <SkBitmap.h>
+#include <cutils/xlog.h>
+#undef ALOGE
+#undef ALOGW
+#undef ALOGI
+#undef ALOGD
+#undef ALOGV
+#define ALOGE XLOGE
+#define ALOGW XLOGW
+#define ALOGI XLOGI
+#define ALOGD XLOGD
+#define ALOGV XLOGD
+#endif
 namespace android {
 
 SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeight) :
@@ -55,6 +71,12 @@ SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeig
     mUseAbsoluteTimestamps(false) {
     ALOGV("SurfaceMediaSource");
 
+#ifdef MTK_HARDWARE
+    mBackupBufsIndex = 0;
+    mBackupBufsMax = 0;
+    
+    mIsBinderDied = false;
+#endif
     if (bufferWidth == 0 || bufferHeight == 0) {
         ALOGE("Invalid dimensions %dx%d", bufferWidth, bufferHeight);
     }
@@ -284,6 +306,10 @@ static void passMetadataBuffer(MediaBuffer **buffer,
 
 status_t SurfaceMediaSource::read(
         MediaBuffer **buffer, const ReadOptions * /* options */) {
+#ifdef MTK_HARDWARE
+    sp<Fence> bufferFence = NULL;
+    {
+#endif 
     ALOGV("read");
     Mutex::Autolock lock(mMutex);
 
@@ -307,6 +333,9 @@ status_t SurfaceMediaSource::read(
             // wait for a buffer to be queued
             mFrameAvailableCondition.wait(mMutex);
         } else if (err == OK) {
+#ifdef MTK_HARDWARE
+            bufferFence = item.mFence;			
+#endif
             err = item.mFence->waitForever("SurfaceMediaSource::read");
             if (err) {
                 ALOGW("read: failed to wait for buffer fence: %d", err);
@@ -382,7 +411,19 @@ status_t SurfaceMediaSource::read(
     mPendingBuffers.push_back(*buffer);
 #endif
 
+#ifndef MTK_HARDWARE
     ALOGV("returning mbuf %p", *buffer);
+#endif
+
+#ifdef MTK_HARDWARE
+    }
+
+    if (bufferFence != NULL) {
+        bufferFence->waitForever("SMS aquire buffer");
+    }
+
+    dumpBuffer();
+#endif
 
     return OK;
 }
@@ -485,6 +526,387 @@ void SurfaceMediaSource::onBuffersReleased() {
        mSlots[i].mGraphicBuffer = 0;
     }
 }
+#ifdef MTK_HARDWARE
+status_t SurfaceMediaSource::binderDied()
+{
+    if (!mStarted) {
+        return OK;
+    }
+
+    XLOGW("[SMS] binder is dead, broadcast");
+    mIsBinderDied = true;    
+    mFrameAvailableCondition.broadcast();
+
+    return OK;
+}
+
+void SurfaceMediaSource::drainBufferQueue()
+{
+    status_t err = OK;
+    BufferQueue::BufferItem item;
+    
+    while (err == OK) {
+
+    }
+}
+
+static uint32_t single_count = 0;
+
+void SurfaceMediaSource::dumpBuffer(){
+    char     value[PROPERTY_VALUE_MAX];
+    property_get("debug.sms.layerdump", value, "0");
+
+    int param = atoi(value);
+
+    if (param == 1)
+        single_count ++;
+    else
+        single_count = 0;
+
+    switch (param)
+    {
+    case -1:
+        system("mkdir /data/SMS_dump");
+        activeBufferBackup();
+        break;
+
+    case 0:
+        dumpContinuousBuffer();
+        break;
+
+    case 1:
+        system("mkdir /data/SMS_dump");
+        dumpSingleBuffer();
+        break;
+
+    default:
+        return;
+    }
+}
+
+void SurfaceMediaSource::dumpSingleBuffer()
+{
+    sp<GraphicBuffer> graphicBuffer = mSlots[mCurrentSlot].mGraphicBuffer;
+    if (graphicBuffer != NULL) {
+        bool     raw = false;
+        uint32_t identity;
+
+        char             fname[128];
+        void*            ptr;
+        float            bpp;
+        SkBitmap         b;
+        SkBitmap::Config c;
+
+        bpp = 1.0f;
+        c = SkBitmap::kNo_Config;
+        switch (graphicBuffer->format) {
+            case PIXEL_FORMAT_RGBA_8888:
+            case PIXEL_FORMAT_RGBX_8888:
+                if (false == raw) {
+                    c = SkBitmap::kARGB_8888_Config;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.png", identity);
+                } else {
+                    bpp = 4.0;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.RGBA", identity);
+                }
+                break;
+            case PIXEL_FORMAT_BGRA_8888:
+            case 0x1ff:                     // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
+                if (false == raw) {
+                    c = SkBitmap::kARGB_8888_Config;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d(RBswapped).png", identity);
+                } else {
+                    bpp = 4.0;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.BGRA", identity);
+                }
+                break;
+            case PIXEL_FORMAT_RGB_565:
+                if (false == raw) {
+                    c = SkBitmap::kRGB_565_Config;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.png", identity);
+                } else {
+                    bpp = 2.0;
+                    sprintf(fname, "/data/SMS_dump/sms_%03d.RGB565", identity);
+                }
+                break;
+            case HAL_PIXEL_FORMAT_I420:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.i420", identity);
+                break;
+            case HAL_PIXEL_FORMAT_NV12_BLK:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.nv12_blk", identity);
+                break;
+            case HAL_PIXEL_FORMAT_NV12_BLK_FCM:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.nv12_blk_fcm", identity);
+                break;
+            case HAL_PIXEL_FORMAT_YV12:
+                bpp = 1.5;
+                sprintf(fname, "/data/SMS_dump/sms_%03d.yv12", identity);
+                break;
+            default:
+                XLOGE("[%s] cannot dump format:%d for identity:%d",
+                      __func__, graphicBuffer->format, identity);
+                return;
+        }
+
+        {
+            //Mutex::Autolock _l(mDumpLock);
+            graphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN, &ptr);
+            {
+                XLOGI("    %s (config:%d, stride:%d, height:%d, ptr:%p)",
+                    fname, c, graphicBuffer->stride, graphicBuffer->height, ptr);
+
+                if (SkBitmap::kNo_Config != c) {
+                    b.setConfig(c, graphicBuffer->stride, graphicBuffer->height);
+                    b.setPixels(ptr);
+                    SkImageEncoder::EncodeFile(fname, b, SkImageEncoder::kPNG_Type,
+                                               SkImageEncoder::kDefaultQuality);
+                } else {
+                    uint32_t size = graphicBuffer->stride * graphicBuffer->height * bpp;
+                    FILE *f = fopen(fname, "wb");
+                    if (f != NULL)
+                    {
+                        fwrite(ptr, size, 1, f);
+                        fclose(f);
+                    }
+                    else
+                        XLOGW("file %s open fail", fname);
+                }
+            }
+            graphicBuffer->unlock();
+        }
+    }
+}
+
+void SurfaceMediaSource::activeBufferBackup() {
+
+    sp<GraphicBuffer> graphicBuffer = mSlots[mCurrentSlot].mGraphicBuffer;
+    
+    if (graphicBuffer == NULL) {
+        XLOGW("[SMS::activeBufferBackup] graphicBuffer=%p not initialized", graphicBuffer.get());
+        return;
+    }
+    
+    if (true) {
+        XLOGV("[SMS::activeBufferBackup] +");
+        // check bpp
+        float bpp = 0.0f;
+        uint32_t width  = graphicBuffer->width;
+        uint32_t height = graphicBuffer->height;
+        uint32_t format = graphicBuffer->format;
+        uint32_t usage  = graphicBuffer->usage;
+        uint32_t stride = graphicBuffer->stride;
+        status_t err;
+        
+        switch (graphicBuffer->format) {
+            case PIXEL_FORMAT_RGBA_8888:
+            case PIXEL_FORMAT_BGRA_8888:
+            case PIXEL_FORMAT_RGBX_8888:
+            case 0x1ff:
+                // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
+                bpp = 4.0;
+                break;
+            case PIXEL_FORMAT_RGB_565:
+                bpp = 2.0;
+                break;
+            case HAL_PIXEL_FORMAT_I420:
+                bpp = 1.5;
+                break;
+            case HAL_PIXEL_FORMAT_YV12:
+                bpp = 1.5;
+                break;
+            default:
+                XLOGE("[%s] SMS cannot dump format:%d for identity", __func__, graphicBuffer->format);
+                break;
+        }
+
+#define MAX_DEFAULT_BUFFERS 10
+        // initialize backup buffer max size
+        char value[PROPERTY_VALUE_MAX];
+
+        property_get("debug.sf.contbufsmax", value, "0");
+        uint32_t max = atoi(value);
+        if (max <= 0)
+            max = MAX_DEFAULT_BUFFERS;
+
+        if (mBackupBufsMax != max) {
+            mBackupBufsMax = max;
+            XLOGI("==>  ring buffer max size, max = %d", max);
+
+            mBackBufs.clear();
+            mBackupBufsIndex = 0;
+        }
+
+        // create new GraphicBuffer
+        if (mBackBufs.size() < mBackupBufsMax) {
+            sp<GraphicBuffer> buf;
+            buf = new GraphicBuffer(width, height, format, usage);
+            mBackBufs.push(buf);
+
+            XLOGI("[SMS] new buffer for cont. dump, size = %d", mBackBufs.size());
+        }
+
+        // detect geometry changed
+        if (mBackBufs[mBackupBufsIndex]->width != graphicBuffer->width || 
+            mBackBufs[mBackupBufsIndex]->height != graphicBuffer->height ||
+            mBackBufs[mBackupBufsIndex]->format != graphicBuffer->format) {
+            XLOGI("[SMS] geometry changed, backup=(%d, %d, %d) ==> active=(%d, %d, %d)",
+                mBackBufs[mBackupBufsIndex]->width,
+                mBackBufs[mBackupBufsIndex]->height,
+                mBackBufs[mBackupBufsIndex]->format,
+                graphicBuffer->width,
+                graphicBuffer->height,
+                graphicBuffer->format);
+
+            sp<GraphicBuffer> buf;
+            buf = new GraphicBuffer(width, height, format, usage);
+            mBackBufs.replaceAt(buf, mBackupBufsIndex);
+        }
+
+        if (graphicBuffer.get() == NULL || mBackBufs[mBackupBufsIndex] == NULL) {
+            XLOGW("[SMS::activeBufferBackup] backup fail, graphicBuffer=%p, mBackBufs[%d]=%p",
+                graphicBuffer.get(), mBackupBufsIndex, mBackBufs[mBackupBufsIndex].get());
+            return;
+        }
+        
+        // backup
+        nsecs_t now = systemTime();        
+
+        void* src;
+        void* dst;
+        err = graphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN, &src);
+        if (err != NO_ERROR) {
+            XLOGW("[SMS::activeBufferBackup] lock active buffer failed");
+            return;
+        }
+
+        XLOGV("[SMS::activeBufferBackup] lock +, req=%d");
+        err = mBackBufs[mBackupBufsIndex]->lock(GraphicBuffer::USAGE_SW_READ_OFTEN | GraphicBuffer::USAGE_SW_WRITE_OFTEN, &dst);
+        if (err != NO_ERROR) {
+            XLOGW("[SMS::activeBufferBackup] lock backup buffer failed");
+            return;
+        }
+
+        backupProcess(dst, src, stride*height*bpp);
+
+        mBackBufs[mBackupBufsIndex]->unlock();
+        graphicBuffer->unlock();
+
+        XLOGI("[SMS::activeBufferBackup] buf=%d, time=%lld", mBackupBufsIndex, ns2ms(systemTime() - now));
+
+        mBackupBufsIndex ++;
+        if (mBackupBufsIndex >= mBackupBufsMax)
+            mBackupBufsIndex = 0;
+    }
+}
+
+void SurfaceMediaSource::backupProcess(void* dst, void* src, size_t size) {
+    XLOGV("[SMS::backupProcess] +");
+
+    // backup 
+    memcpy(dst, src, size);
+
+    XLOGV("[SMS::backupProcess] -");
+}
+
+void SurfaceMediaSource::dumpContinuousBuffer() {
+    char tmp[PROPERTY_VALUE_MAX];
+
+    if (0 == mBackBufs.size())
+        return;
+
+    if (mBackupBufsMax <= 0) {
+        XLOGW("[SMS::dumpContinuousBuffer] mBackupBufsMax not updated");
+        return;
+    }
+
+    XLOGD("[SMS::dumpContinuousBuffer] +, size=%d", mBackBufs.size());
+
+    if (true) {
+        int start = (mBackupBufsIndex + mBackupBufsMax - 1) % mBackupBufsMax;
+        int size = mBackBufs.size();
+        for (uint32_t i = 0; i < mBackupBufsMax; i++) {
+            if (i >= mBackBufs.size()) {
+                XLOGW("[SMS::dumpContinuousBuffer] overflow i=%d, max=%d", i, mBackBufs.size());
+                break;
+            }
+
+            int index = (start + mBackupBufsMax - i) % mBackupBufsMax;
+            XLOGD("[SMS::dumpContinuousBuffer] i=%d, index=%d", mBackupBufsMax - i, index);
+            sp<GraphicBuffer> buf = mBackBufs[index];
+            dumpGraphicBuffer(buf, size - i);
+        }
+    }
+
+    mBackBufs.clear();
+    property_set("debug.sms.layerdump", "0");
+
+    XLOGD("[SMS::dumpContinuousBuffer] -, size=%d", mBackBufs.size());
+}
+
+void SurfaceMediaSource::dumpGraphicBuffer(sp<GraphicBuffer> buf, int index) {
+    char             fname[128];
+    void*            ptr;
+    SkBitmap         b;
+    SkBitmap::Config c;
+    float            bpp;
+    
+    
+    c = SkBitmap::kNo_Config;
+    switch (buf->format) {
+        case PIXEL_FORMAT_RGBA_8888:
+        case PIXEL_FORMAT_BGRA_8888:
+        case PIXEL_FORMAT_RGBX_8888:
+        case 0x1ff:                     // tricky format for SGX_COLOR_FORMAT_BGRX_8888 in fact
+            c = SkBitmap::kARGB_8888_Config;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.png", index);
+            break;
+        case PIXEL_FORMAT_RGB_565:
+            c = SkBitmap::kRGB_565_Config;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.png", index);
+            break;
+        case HAL_PIXEL_FORMAT_I420:
+            bpp = 1.5;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.i420", index);
+            break;
+        case HAL_PIXEL_FORMAT_YV12:
+            bpp = 1.5;
+            sprintf(fname, "/data/SMS_dump/sms_%03d.yv12", index);
+            break;
+        default:
+            XLOGE("[%s] SMS cannot dump format:%d", __func__, buf->format);
+            return;
+    }
+
+    buf->lock(GraphicBuffer::USAGE_SW_READ_OFTEN, &ptr);
+    {
+        XLOGI("[SMS::dumpGraphicBuffer]");
+        XLOGI("    %s (config:%d, stride:%d, height:%d, ptr:%p)",
+            fname, c, buf->stride, buf->height, ptr);
+
+        if (SkBitmap::kNo_Config != c) {
+            b.setConfig(c, buf->stride, buf->height);
+            b.setPixels(ptr);
+            SkImageEncoder::EncodeFile(
+                fname, b, SkImageEncoder::kPNG_Type, SkImageEncoder::kDefaultQuality);
+        } else {
+            uint32_t size = buf->stride * buf->height * bpp;
+            FILE *f = fopen(fname, "wb");
+            if (f != NULL)
+            {
+                fwrite(ptr, size, 1, f);
+                fclose(f);
+            }
+            else
+                XLOGW("file %s open fail", fname);
+        }
+    }
+    buf->unlock();
+}
+
+#endif
 
 void SurfaceMediaSource::onSidebandStreamChanged() {
     ALOG_ASSERT(false, "SurfaceMediaSource can't consume sideband streams");
diff --git a/media/libstagefright/codecs/aacenc/Android.mk b/media/libstagefright/codecs/aacenc/Android.mk
index 58ec3ba6a..c6396d24b 100644
--- a/media/libstagefright/codecs/aacenc/Android.mk
+++ b/media/libstagefright/codecs/aacenc/Android.mk
@@ -82,7 +82,7 @@ LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV5E
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/src/asm/ARMV7
 endif
 
-LOCAL_CFLAGS += -Werror
+#LOCAL_CFLAGS += -Werror
 
 include $(BUILD_STATIC_LIBRARY)
 
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 59a64ba25..a8a1cf0cc 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -9,6 +9,12 @@ LOCAL_C_INCLUDES := \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/hardware/msm7k
 
+
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    LOCAL_C_INCLUDES += \
+        $(TOP)/mediatek/hardware/dpframework/inc 
+endif
+
 LOCAL_MODULE:= libstagefright_color_conversion
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f91..582db959d 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -22,6 +22,20 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaErrors.h>
 
+#ifdef MTK_HARDWARE
+#include "OMX_IVCommon.h"
+#include <ctype.h>
+#include <cutils/properties.h>
+
+#define MEM_ALIGN_32              32
+#define BITBLT_TRYALLOCMEMCOUNT   200
+#include "DpBlitStream.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <cutils/properties.h>
+#include <utils/Timers.h>
+#endif
+
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -37,10 +51,15 @@ ColorConverter::~ColorConverter() {
 }
 
 bool ColorConverter::isValid() const {
+#ifdef MTK_HARDWARE
+	ALOGD ("MTK: isValid: src format: 0x%x, Dst format: 0x%x", 
+		mSrcFormat, mDstFormat);
+    if ((mDstFormat != OMX_COLOR_Format16bitRGB565) && (mDstFormat != OMX_COLOR_Format32bitARGB8888)) {
+#else
     if (mDstFormat != OMX_COLOR_Format16bitRGB565) {
+#endif
         return false;
     }
-
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
@@ -85,9 +104,15 @@ status_t ColorConverter::convert(
         size_t dstWidth, size_t dstHeight,
         size_t dstCropLeft, size_t dstCropTop,
         size_t dstCropRight, size_t dstCropBottom) {
+#ifdef MTK_HARDWARE
+    if ((mDstFormat != OMX_COLOR_Format16bitRGB565) && (mDstFormat != OMX_COLOR_Format32bitARGB8888)) {
+		return ERROR_UNSUPPORTED;
+    }
+#else
     if (mDstFormat != OMX_COLOR_Format16bitRGB565) {
         return ERROR_UNSUPPORTED;
     }
+#endif
 
     BitmapParams src(
             const_cast<void *>(srcBits),
@@ -103,7 +128,11 @@ status_t ColorConverter::convert(
 
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
+#ifdef MTK_HARDWARE
+            err = convertYUVToRGBHW(src, dst);
+#else
             err = convertYUV420Planar(src, dst);
+#endif
             break;
 
         case OMX_COLOR_FormatCbYCrY:
@@ -122,6 +151,14 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
+#ifdef MTK_HARDWARE
+        case OMX_MTK_COLOR_FormatYV12:
+        case OMX_COLOR_FormatVendorMTKYUV:
+        case OMX_COLOR_FormatVendorMTKYUV_FCM:
+            err = convertYUVToRGBHW(src, dst);
+            break;
+#endif
+
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -521,4 +558,226 @@ uint8_t *ColorConverter::initClip() {
     return &mClip[-kClipMin];
 }
 
+#ifdef MTK_HARDWARE
+// convert MTKYUV to RGB565 (SW)
+bool ColorConverter::SWYUVToRGBConversion(const BitmapParams &src, const BitmapParams &dst)
+{
+    status_t err;
+
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565) {
+        err = convertYUV420Planar(src, dst);
+    }
+    else if (mDstFormat == OMX_COLOR_Format32bitARGB8888) {
+        err = convertYUV420PlanarToABGR8888(src, dst);
+    }
+    else {
+        ALOGE ("[ERROR] Unsupported dst format (0x%08X) in SWYUVToRGBConversion");
+        err = ERROR_UNSUPPORTED;
+    }
+
+    if (err == OK) {
+        return true;
+    }
+    else {
+        return false;
+    }
+}
+
+status_t ColorConverter::convertYUVToRGBHW(const BitmapParams &src, const BitmapParams &dst)
+{
+	ALOGD("srcWidth(%d), srcHeight(%d), srcCropLeft(%d), srcCropTop(%d), srcCropRight(%d), srcCropBottom(%d)",
+       src.mWidth, src.mHeight, src.mCropLeft, src.mCropTop, src.mCropRight, src.mCropBottom);
+    ALOGD("dstWidth(%d), dstHeight(%d), dstCropLeft(%d), dstCropTop(%d), dstCropRight(%d), dstCropBottom(%d)",
+       dst.mWidth, dst.mHeight, dst.mCropLeft, dst.mCropTop, dst.mCropRight, dst.mCropBottom);
+    DpBlitStream blitStream;
+
+//    int srcWidth = src.cropWidth();
+//    int srcHeight = src.cropHeight();
+// reverse-engineered color conversion from JB libstagefright.so for mt6589 by blackrebel
+
+       int srcHStride = src.mHeight; 
+       int srcWStride = src.mWidth;
+       
+    if (mSrcFormat != OMX_COLOR_FormatYUV420Planar) {
+       srcWStride = (src.mWidth + 15) & 0xFFFFFFF0;
+       srcHStride = (src.mHeight + 31) & 0xFFFFFFE0;
+    }
+	
+    DpRect srcRoi;
+    srcRoi.x = 0;
+    srcRoi.y = 0;
+    srcRoi.w = dst.mWidth;
+    srcRoi.h = dst.mHeight;
+
+    ALOGD("convertYUVToRGBHW: src stride aligned, w(%d), h(%d)", srcWStride, srcHStride);
+
+    unsigned int dstWStride = dst.mWidth ;
+    unsigned int dstHStride = dst.mHeight ;
+
+    if (mSrcFormat == OMX_COLOR_FormatYUV420Planar) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+	      length[1] = srcWStride*srcHStride/4;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+	ALOGD("OMX_COLOR_FormatYUV420Planar: Yaddr(%p), Uaddr(%p), Vaddr(%p) YUV420P", planar[0], planar[1], planar[2]);
+	ALOGD("OMX_COLOR_FormatYUV420Planar: Ylen(%d), Ulen(%d), Vlen(%d)", length[0], length[1], length[2]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 3, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eYUV_420_3P);
+    }
+/*
+	if (mSrcFormat == OMX_MTK_COLOR_FormatYV12) {
+        char* planar[3];
+        unsigned int length[3];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/4;
+        planar[2] = planar[1] + length[1];
+        length[2] = length[1];
+	ALOGD("OMX_MTK_COLOR_FormatYV12: Yaddr(%p), Uaddr(%p), Vaddr(%p) YV12", planar[0], planar[1], planar[2]);
+	ALOGD("OMX_MTK_COLOR_FormatYV12: Ylen(%d), Ulen(%d), Vlen(%d)", length[0], length[1], length[2]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 3, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eYV12);
+    }
+*/
+    if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+	ALOGD("OMX_COLOR_FormatVendorMTKYUV: Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+	ALOGD("OMX_COLOR_FormatVendorMTKYUV: Ylen(%d), Clen(%d)", length[0], length[1]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 2, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eNV12_BLK);	
+    //    blitStream.setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    if (mSrcFormat == OMX_COLOR_FormatVendorMTKYUV_FCM) {
+        char* planar[2];
+        unsigned int length[2];
+        planar[0] = (char*)src.mBits;
+        length[0] = srcWStride*srcHStride;
+        planar[1] = planar[0] + length[0];
+        length[1] = srcWStride*srcHStride/2;
+	ALOGD("Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+	ALOGD("Ylen(%d), Clen(%d)", length[0], length[1]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 2, 0);
+	blitStream.setSrcConfig(srcWStride, srcHStride, eNV12_BLK_FCM);
+	//blitStream.setSrcConfig(srcWStride, srcHStride, srcWStride * 32, srcWStride * 16, eNV12_BLK_FCM, DP_PROFILE_BT601, eInterlace_None, &srcRoi);
+    }
+    if (mSrcFormat == OMX_COLOR_Format32bitARGB8888) {
+	char* planar[1];
+	unsigned int length[1];
+	planar[0] = (char*)src.mBits;
+	length[0] = srcWStride*srcHStride*4;
+	ALOGD("OMX_COLOR_Format32bitARGB8888: Yaddr(%p), Caddr(%p)", planar[0], planar[1]);
+	ALOGD("OMX_COLOR_Format32bitARGB8888: Ylen(%d), Clen(%d)", length[0], length[1]);
+
+	blitStream.setSrcBuffer((void**)planar, (unsigned int*)length, 1);
+        blitStream.setSrcConfig(srcWStride, srcHStride, eRGBA8888);
+    }
+
+
+    ALOGD("dst addr(%p), w(%d), h(%d)", dst.mBits, dstWStride, dstHStride);
+    if (mDstFormat == OMX_COLOR_Format16bitRGB565) {
+	blitStream.setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 2, 0);
+        blitStream.setDstConfig(dst.mWidth, dst.mHeight, eRGB565);
+      ALOGD("dst color format: OMX_COLOR_Format16bitRGB565");
+    }
+    else if (mDstFormat == OMX_COLOR_Format32bitARGB8888) {
+	blitStream.setDstBuffer(dst.mBits, dst.mWidth * dst.mHeight * 4, 0);
+	blitStream.setDstConfig(dst.mWidth, dst.mHeight, eABGR8888);
+      ALOGD("dst color format: OMX_COLOR_Format32bitABGR8888");
+    }
+
+
+    // Add Sharpness in Video Thumbnail
+    blitStream.setTdshp(1);
+    bool bRet = blitStream.invalidate();
+    ALOGI("blitStream return %d.", bRet);
+
+	
+    if (!bRet)
+        return OK;
+    else
+    ALOGI("UNKNOWN ERROR");
+        return UNKNOWN_ERROR;
+
+    return OK;
+}
+
+
+status_t ColorConverter::convertYUV420PlanarToABGR8888(const BitmapParams &src, const BitmapParams &dst) {
+
+    ALOGD ("ColorConverter::convertYUV420PlanarToABGR8888(SW) src.cropWidth(%d), src.cropHeight(%d), dst.cropWidth(%d), dst.cropHeight(%d)",
+        src.cropWidth(), src.cropHeight(), dst.cropWidth(), dst.cropHeight());
+
+    if (!((src.mCropLeft & 1) == 0
+            && src.cropWidth() == dst.cropWidth()
+            && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint8_t *kAdjustedClip = initClip();
+
+    uint32_t *dst_ptr = (uint32_t *)dst.mBits + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+    
+    const uint8_t *src_y =  (const uint8_t *)src.mBits + src.mCropTop * src.mWidth + src.mCropLeft;
+
+    const uint8_t *src_u =
+       (const uint8_t *)src_y + src.mWidth * src.mHeight
+        + src.mCropTop * (src.mWidth / 2) + src.mCropLeft / 2;
+
+    const uint8_t *src_v =
+       src_u + (src.mWidth / 2) * (src.mHeight / 2);
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x++) {
+            signed y1 = (signed)src_y[x] - 16;
+            signed u = (signed)src_u[x / 2] - 128;
+            signed v = (signed)src_v[x / 2] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+	    uint32_t rgb1 =
+                  (kAdjustedClip[r1] << 0)
+                | (kAdjustedClip[g1] << 8)
+                | (kAdjustedClip[b1] << 16)
+                | (0xFF << 24);
+                                               
+            dst_ptr[x] = rgb1;
+        }
+
+        src_y += src.mWidth;
+
+        if (y & 1) {
+            src_u += src.mWidth / 2;
+            src_v += src.mWidth / 2;
+        }
+
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/include/OMX.h b/media/libstagefright/include/OMX.h
index 829c38b59..83abfff12 100644
--- a/media/libstagefright/include/OMX.h
+++ b/media/libstagefright/include/OMX.h
@@ -83,6 +83,25 @@ public:
             node_id node, OMX_U32 port_index, const sp<IMemory> &params,
             buffer_id *buffer, OMX_BOOL crossProcess);
 
+#ifdef MTK_HARDWARE
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer);
+
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer);
+
+    virtual status_t registerBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap);
+
+    virtual status_t registerBuffer2(
+            node_id node, OMX_U32 port_index,  const sp<IMemoryHeap> &HeapBase);
+
+  virtual status_t useIonBuffer(
+            node_id node, OMX_U32 port_index,
+            unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer);
+#endif
     virtual status_t useGraphicBuffer(
             node_id node, OMX_U32 port_index,
             const sp<GraphicBuffer> &graphicBuffer, buffer_id *buffer);
diff --git a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
index 616dda1a8..3813ddcc2 100644
--- a/media/libstagefright/include/OMXNodeInstance.h
+++ b/media/libstagefright/include/OMXNodeInstance.h
@@ -75,6 +75,25 @@ struct OMXNodeInstance {
             OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
             OMX::buffer_id *buffer);
 
+#ifdef MTK_HARDWARE
+    status_t useBuffer(
+            OMX_U32 portIndex, unsigned char* virAddr, size_t size,
+            OMX::buffer_id *buffer);
+
+    status_t useBuffer(
+            OMX_U32 portIndex, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            OMX::buffer_id *buffer);
+
+    status_t registerBuffer(
+            OMX_U32 portIndex, const sp<IMemoryHeap> &heap);
+
+    status_t registerBuffer2(
+            OMX_U32 portIndex, const sp<IMemoryHeap> &HeapBase);
+
+    status_t useIonBuffer(
+            OMX_U32 port_index, unsigned char* virAddr, OMX_S32 fd, size_t size, OMX::buffer_id *buffer);
+#endif
+
     status_t updateGraphicBufferInMeta(
             OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
             OMX::buffer_id buffer);
@@ -133,6 +152,9 @@ private:
     OMX::node_id mNodeID;
     OMX_HANDLETYPE mHandle;
     sp<IOMXObserver> mObserver;
+#ifdef MTK_HARDWARE
+    sp<IMemoryHeap> mHeap;
+#endif
     bool mDying;
     bool mSailed;  // configuration is set (no more meta-mode changes)
     bool mQueriedProhibitedExtensions;
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index 44080507c..26e96f265 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -37,6 +37,17 @@ ifeq ($(DTS_CODEC_M_), true)
   LOCAL_CFLAGS += -DDTS_CODEC_M_
 endif
 
+
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+    LOCAL_C_INCLUDES += \
+        $(TOP)/frameworks/av/media/libstagefright/include \
+        $(TOP)/mediatek/frameworks/av/media/libstagefright/include
+
+    LOCAL_SHARED_LIBRARIES += \
+        libstagefright_memutil
+
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index 390c6bed3..467c33b0d 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -87,7 +87,12 @@ OMX::CallbackDispatcher::CallbackDispatcher(OMXNodeInstance *owner)
     : mOwner(owner),
       mDone(false) {
     mThread = new CallbackDispatcherThread(this);
+#ifndef ANDROID_DEFAULT_CODE
+    // Promote OMX callback dipatcher to AUDIO priority
+    mThread->run("OMXCallbackDisp", ANDROID_PRIORITY_AUDIO);
+#else
     mThread->run("OMXCallbackDisp", ANDROID_PRIORITY_FOREGROUND);
+#endif //ANDROID_DEFAULT_CODE
 }
 
 OMX::CallbackDispatcher::~CallbackDispatcher() {
@@ -391,6 +396,39 @@ status_t OMX::signalEndOfInputStream(node_id node) {
     return findInstance(node)->signalEndOfInputStream();
 }
 
+#ifdef MTK_HARDWARE
+ status_t OMX::useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size,
+            buffer_id *buffer) {
+    return findInstance(node)->useBuffer(
+            port_index, virAddr, size, buffer);
+}
+
+status_t OMX::useBuffer(
+            node_id node, OMX_U32 port_index, unsigned char* virAddr, size_t size, OMX_U32 offset,
+            buffer_id *buffer) {
+    return findInstance(node)->useBuffer(
+            port_index, virAddr, size, offset, buffer);
+}
+
+status_t OMX::registerBuffer(
+        node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &heap) {
+    return findInstance(node)->registerBuffer(
+            port_index, heap);
+}
+
+status_t OMX::registerBuffer2(
+        node_id node, OMX_U32 port_index, const sp<IMemoryHeap> &HeapBase) {
+    return findInstance(node)->registerBuffer2(
+            port_index, HeapBase);
+}
+
+status_t OMX::useIonBuffer(
+        node_id node, OMX_U32 port_index, unsigned char* virAddr, OMX_S32 fd, size_t size, buffer_id *buffer) {
+    return findInstance(node)->useIonBuffer(
+            port_index, virAddr, fd, size, buffer);
+}
+#endif
 status_t OMX::allocateBuffer(
         node_id node, OMX_U32 port_index, size_t size,
         buffer_id *buffer, void **buffer_data) {
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 9d384c5df..f3f7a5097 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -35,6 +35,25 @@
 #include <media/stagefright/MediaErrors.h>
 
 #include <utils/misc.h>
+#ifdef MTK_HARDWARE
+#include "sf_mem_util.h"
+#define USE_VIDEO_M4U
+
+struct UseIonBufferParams {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_PTR pAppPrivate;
+    unsigned char* virAddr;
+    OMX_S32 Ionfd;
+    size_t size;
+    OMX_BUFFERHEADERTYPE **bufferHeader;
+};
+
+#define ENABLE_MTK_BUF_ADDR_ALIGNMENT
+#define MTK_BUF_ADDR_ALIGNMENT_VALUE 512
+#endif
+
 
 static const OMX_U32 kPortIndexInput = 0;
 static const OMX_U32 kPortIndexOutput = 1;
@@ -157,7 +176,12 @@ struct BufferMeta {
     ~BufferMeta() {
         delete[] mBackup;
     }
-
+#ifdef MTK_HARDWARE
+    sp<IMemory> GetMem()
+    {
+        return mMem;
+    }
+#endif
 private:
     sp<GraphicBuffer> mGraphicBuffer;
     sp<IMemory> mMem;
@@ -191,6 +215,9 @@ OMXNodeInstance::OMXNodeInstance(
       mNodeID(0),
       mHandle(NULL),
       mObserver(observer),
+#ifdef MTK_HARDWARE
+      mHeap(NULL),
+#endif
       mDying(false),
       mSailed(false),
       mQueriedProhibitedExtensions(false),
@@ -212,6 +239,14 @@ OMXNodeInstance::OMXNodeInstance(
 OMXNodeInstance::~OMXNodeInstance() {
     free(mName);
     CHECK(mHandle == NULL);
+
+#ifdef MTK_HARDWARE
+    if (mHeap != NULL)
+    {
+        sf_memheap_remove_info (mHeap->getBase());
+        mHeap = NULL;
+    }
+#endif
 }
 
 void OMXNodeInstance::setHandle(OMX::node_id node_id, OMX_HANDLETYPE handle) {
@@ -763,9 +798,25 @@ status_t OMXNodeInstance::useBuffer(
 
     OMX_BUFFERHEADERTYPE *header;
 
+#ifdef MTK_HARDWARE
+  #ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    OMX_U8 *ptr = static_cast<OMX_U8 *>(params->pointer());
+    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr)+(MTK_BUF_ADDR_ALIGNMENT_VALUE-1))&~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+  #else
+    OMX_U8 *ptr = static_cast<OMX_U8 *>(params->pointer());
+    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr));
+  #endif
+#else
+    // do nothing
+#endif
     OMX_ERRORTYPE err = OMX_UseBuffer(
             mHandle, &header, portIndex, buffer_meta,
-            params->size(), data);
+#ifdef MTK_HARDWARE
+            params->size(), (OMX_U8 *)pBuffer
+#else
+            params->size(), data)
+#endif
+            );
 
     if (err != OMX_ErrorNone) {
         CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(portIndex, params->size(), params->pointer()));
@@ -794,6 +845,193 @@ status_t OMXNodeInstance::useBuffer(
     return OK;
 }
 
+#ifdef MTK_HARDWARE
+status_t OMXNodeInstance::useBuffer(
+         OMX_U32 portIndex, unsigned char* virAddr, size_t size,
+        OMX::buffer_id *buffer) {
+    Mutex::Autolock autoLock(mLock);
+
+    BufferMeta *buffer_meta = new BufferMeta(NULL, portIndex);
+
+    OMX_BUFFERHEADERTYPE *header;
+
+    //ALOGE ("@@ OMX_UseBuffer2 virAddr=0x%x", virAddr);
+    
+    OMX_ERRORTYPE err = OMX_UseBuffer(
+            mHandle, &header, portIndex, buffer_meta,
+            size, static_cast<OMX_U8 *>(virAddr));
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
+
+        delete buffer_meta;
+        buffer_meta = NULL;
+
+        *buffer = 0;
+
+        return UNKNOWN_ERROR;
+    }
+
+    *buffer = makeBufferID(header);
+
+    addActiveBuffer(portIndex, *buffer);
+
+    return OK;
+ }
+
+ status_t OMXNodeInstance::useBuffer(
+        OMX_U32 portIndex, unsigned char* virAddr, size_t size, OMX_U32 offset,
+        OMX::buffer_id *buffer) {
+    Mutex::Autolock autoLock(mLock);
+    unsigned char *vAddr = virAddr;
+
+    if (mHeap == NULL) 
+        return UNKNOWN_ERROR;
+
+    BufferMeta *buffer_meta = new BufferMeta(NULL, portIndex);
+
+    OMX_BUFFERHEADERTYPE *header;
+
+    void *base = mHeap->getBase();
+    vAddr = (unsigned char *)base + offset;
+
+// Morris Yang alignment patch [
+#ifdef ENABLE_MTK_BUF_ADDR_ALIGNMENT
+    unsigned char* ptr = reinterpret_cast<unsigned char*>(base);
+    OMX_U32 pBuffer = ((reinterpret_cast<OMX_U32>(ptr)+(MTK_BUF_ADDR_ALIGNMENT_VALUE-1))&~(MTK_BUF_ADDR_ALIGNMENT_VALUE-1));
+    vAddr = (unsigned char *)(pBuffer+offset);
+#else
+    // do nothing
+#endif
+    ALOGD ("@@ useBuffer[OUT] ptr(0x%08X), pBuffer(0x%08X), vAddr(0x%08X)", ptr, pBuffer, vAddr);
+// ]
+
+    OMX_ERRORTYPE err = OMX_UseBuffer(
+            mHandle, &header, portIndex, buffer_meta,
+            size, static_cast<OMX_U8 *>(vAddr));
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
+
+        delete buffer_meta;
+        buffer_meta = NULL;
+
+        *buffer = 0;
+
+        return UNKNOWN_ERROR;
+    }
+
+    *buffer = makeBufferID(header);
+
+    addActiveBuffer(portIndex, *buffer);
+
+    return OK;
+ }
+
+status_t OMXNodeInstance::registerBuffer(
+        OMX_U32 portIndex, const sp<IMemoryHeap> &heap) {
+    Mutex::Autolock autoLock(mLock);
+
+    // Unregister pmem
+    if (mHeap != NULL)
+    {
+        ExPmemInfo rInfo;
+        rInfo.base = mHeap->getBase();
+        rInfo.size = mHeap->getSize();
+        rInfo.shared_fd = mHeap->getHeapID();
+        rInfo.offset = 0;
+
+        if (!sf_pmem_unregister(&rInfo)) {
+            ALOGE("pmem unregister err: 0x%X, offset: 0x%X !", (unsigned)rInfo.base, rInfo.offset);
+        }
+        mHeap = NULL;
+    }
+
+    mHeap = heap;
+
+    // Register pmem
+    ExPmemInfo rInfo;
+    rInfo.base = mHeap->getBase();
+    rInfo.size = mHeap->getSize();
+    rInfo.shared_fd = mHeap->getHeapID();
+    rInfo.offset = 0;
+    if (!sf_pmem_register(&rInfo)) {
+        ALOGE("pmem register err: 0x%X, offset: 0x%X !", (unsigned)rInfo.base, rInfo.offset);
+    }
+
+    return OK;
+}
+
+status_t OMXNodeInstance::registerBuffer2(
+        OMX_U32 portIndex, const sp<IMemoryHeap> &HeapBase) {
+    Mutex::Autolock autoLock(mLock);
+
+    MemHeapInfo memheapinfo;
+
+    mHeap = HeapBase;
+    memheapinfo.base = (unsigned char*) mHeap->getBase();
+    memheapinfo.mMemHeapBase = (int) mHeap.get();
+    memheapinfo.size = mHeap->getSize();
+    ALOGD("registerBuffer2: base = 0x%08X, mMemHeapBase = 0x%08X, size = %d", (unsigned int)memheapinfo.base, (unsigned int)memheapinfo.mMemHeapBase, (unsigned int)memheapinfo.size);
+    sf_memheap_set_info(&memheapinfo);
+
+    return OK;
+}
+
+status_t OMXNodeInstance::useIonBuffer(
+            OMX_U32 portIndex, unsigned char* virAddr, OMX_S32 fd, size_t size, OMX::buffer_id *buffer) {
+    Mutex::Autolock autoLock(mLock);
+
+    OMX_INDEXTYPE index;
+    OMX_ERRORTYPE err = OMX_GetExtensionIndex(
+            mHandle,
+            const_cast<OMX_STRING>("OMX.MTK.VIDEO.index.useIonBuffer"),
+            &index);
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_GetExtensionIndex failed");
+
+        return StatusFromOMXError(err);
+}
+
+    BufferMeta *bufferMeta = new BufferMeta(NULL, portIndex);
+
+    OMX_BUFFERHEADERTYPE *header;
+
+    OMX_VERSIONTYPE ver;
+    ver.s.nVersionMajor = 1;
+    ver.s.nVersionMinor = 0;
+    ver.s.nRevision = 0;
+    ver.s.nStep = 0;
+
+    UseIonBufferParams params = {
+        sizeof(UseIonBufferParams), ver, portIndex, bufferMeta,
+        virAddr, fd, size, &header
+    };
+    
+    err = OMX_SetParameter(mHandle, index, &params);
+
+    if (err != OMX_ErrorNone) {
+        ALOGE("OMX_UseAndroidNativeBuffer failed with error %d (0x%08x)", err,
+                err);
+
+        delete bufferMeta;
+        bufferMeta = NULL;
+
+        *buffer = 0;
+
+        return UNKNOWN_ERROR;
+    }
+
+    CHECK_EQ(header->pAppPrivate, bufferMeta);
+
+    *buffer = makeBufferID(header);
+
+    addActiveBuffer(portIndex, *buffer);
+
+    return OK;
+}
+#endif
 status_t OMXNodeInstance::useGraphicBuffer2_l(
         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id *buffer) {
@@ -853,12 +1091,15 @@ status_t OMXNodeInstance::useGraphicBuffer(
 
     // See if the newer version of the extension is present.
     OMX_INDEXTYPE index;
+
+#ifndef MTK_HARDWARE
     if (OMX_GetExtensionIndex(
             mHandle,
             const_cast<OMX_STRING>("OMX.google.android.index.useAndroidNativeBuffer2"),
             &index) == OMX_ErrorNone) {
         return useGraphicBuffer2_l(portIndex, graphicBuffer, buffer);
     }
+#endif
 
     OMX_STRING name = const_cast<OMX_STRING>(
         "OMX.google.android.index.useAndroidNativeBuffer");
-- 
2.15.1

